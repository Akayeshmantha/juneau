<!DOCTYPE HTML>
<!--
    Licensed Materials - Property of IBM
    (c) Copyright IBM Corporation 2014, 2015. All Rights Reserved.
   
    Note to U.S. Government Users Restricted Rights:  
    Use, duplication or disclosure restricted by GSA ADP Schedule 
    Contract with IBM Corp. 
 -->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<style type="text/css">
		/* For viewing in Page Designer */
		@IMPORT url("../../../../../javadoc.css");

		/* For viewing in REST interface */
		@IMPORT url("../htdocs/javadoc.css");
		body { 
			margin: 20px; 
		}	
	</style>
	<script>
		/* Replace all @code and @link tags. */	
		window.onload = function() {
			document.body.innerHTML = document.body.innerHTML.replace(/\{\@code ([^\}]+)\}/g, '<code>$1</code>');
			document.body.innerHTML = document.body.innerHTML.replace(/\{\@link (([^\}]+)\.)?([^\.\}]+)\}/g, '<code>$3</code>');
		}
	</script>
</head>
<body>
<p>REST Servlet API</p>

<script>
	function toggle(x) {
		var div = x.nextSibling;
		while (div != null && div.nodeType != 1)
			div = div.nextSibling;
		if (div != null) {
			var d = div.style.display;
			if (d == 'block' || d == '') {
				div.style.display = 'none';
				x.className += " closed";
			} else {
				div.style.display = 'block';
				x.className = x.className.replace(/(?:^|\s)closed(?!\S)/g , '' );
			}
		}
	}
</script>

<p>
	Defines an API for defining REST resources as servlets.
</p>

<a name='TOC'></a><h5 class='toc'>Table of Contents</h5>
<ol class='toc'>
	<li><p><a class='doclink' href='#Intro'>Introduction</a></p>
	<li><p><a class='doclink' href='#HelloWorldResource'>Hello World Example</a></p>
	<li><p><a class='doclink' href='#ClassHierarchy'>Class Hierarchy</a></p>
	<li><p><a class='doclink' href='#RestResources'>REST Servlets</a></p>
	<ol>
		<li><p><a class='doclink' href='#RestResources.MethodSignature'>REST Java Method Signature</a></p>
		<ol>
			<li><p><a class='doclink' href='#RestResources.MethodSignature.Path'>Path</a></p>
			<li><p><a class='doclink' href='#RestResources.MethodSignature.Matchers'>Matchers</a></p>
		</ol>
		<li><p><a class='doclink' href='#RestResources.RequestContent'>Request Content</a></p>
	<ol>
			<li><p><a class='doclink' href='#RestResources.RequestContent.FormPosts'>Form Posts</a></p>
			<li><p><a class='doclink' href='#RestResources.RequestContent'>Multipart Form Posts</a></p>
		</ol>
		<li><p><a class='doclink' href='#RestResources.ResponseContent'>Response Content</a></p>
		<li><p><a class='doclink' href='#RestResources.OptionsPages'>OPTIONS Pages</a></p>
		<li><p><a class='doclink' href='#RestResources.Serializers'>Serializers</a></p>
		<li><p><a class='doclink' href='#RestResources.Parsers'>Parsers</a></p>
		<li><p><a class='doclink' href='#RestResources.Properties'>Properties</a></p>
		<li><p><a class='doclink' href='#RestResources.Filters'>Filters</a></p>
		<li><p><a class='doclink' href='#RestResources.Guards'>Guards</a></p>
		<li><p><a class='doclink' href='#RestResources.Converters'>Converters</a></p>
		<li><p><a class='doclink' href='#RestResources.Children'>Child Resources</a></p>
		<li><p><a class='doclink' href='#RestResources.Labels'>Localized Messages</a></p>
		<li><p><a class='doclink' href='#RestResources.Encoders'>Encoders</a></p>
		<li><p><a class='doclink' href='#RestResources.StringVars'>String Variables</a></p>
		<li><p><a class='doclink' href='#RestResources.StaticFiles'>Static Files</a></p>
		<li><p><a class='doclink' href='#RestResources.Listeners'>Listener Methods</a></p>	
		<li><p><a class='doclink' href='#RestResources.Stylesheet'>Stylesheet</a></p>	
		<li><p><a class='doclink' href='#RestResources.Headers'>Default Headers</a></p>
		<li><p><a class='doclink' href='#RestResources.Errors'>Handling Errors / Logging</a></p>
		<li><p><a class='doclink' href='#RestResources.ConfigFile'>Configuration Files</a></p>
		<li><p><a class='doclink' href='#RestResources.Inheritence'>Annotation Inheritence</a></p>
		<li><p><a class='doclink' href='#RestResources.HttpStatusCodes'>HTTP Status Codes</a></p>
		<li><p><a class='doclink' href='#RestResources.OverloadedHttpMethods'>Overloaded HTTP Methods</a></p>
		<li><p><a class='doclink' href='#RestResources.BuildInParams'>Built-In Parameters</a></p>
		<li><p><a class='doclink' href='#RestResources.CustomSerializersParsers'>Defining your own serializers/parsers</a></p>
		<li><p><a class='doclink' href='#RestResources.ResponseHandlers'>Response Handlers</a></p>
		<li><p><a class='doclink' href='#RestResources.OtherNotes'>Other Notes</a></p>
	</ol>
	<li><p><a class='doclink' href='#Osgi'>Using with OSGi</a></p>
	<li><p><a class='doclink' href='#PojosConvertableFromString'>POJOs Convertable From Strings</a></p>
	<li><p><a class='doclink' href='#AddressBookResource'>Address Book Resource</a></p>
</ol>

<!-- ======================================================================================================== -->
<a name="Intro"></a>
<h2 class='topic' onclick='toggle(this)'>1 - Introduction</h2>
<div class='topic'>
	<p>
		The <l>juno-server.jar</l> library allows you to quickly wrap POJOs and expose them as full-fledged REST resources served up in a servlet container using a bare-minimum amount of code.
		The primary goal for Juno was to make it as easy as possible to implement easy-to-read and self-documenting REST resources using very little code.
	</p>
	<p>
		One of the biggest advantages of the Juno REST framework over similar architectures is that it hides the serialization layer from the developer.  
		The developer can work entirely with POJOs and let the Juno framework handle all the serialization and parsing work.  
		The developer need never know what the <l>Accept</l> or <l>Content-Type</l> or <l>Accept-Encoding</l> (etc...) header values are because those details are all handled by the framework. 
	</p>
	<p> 
		The API builds upon the existing JEE Servlet API.  
		The root class, {@link com.ibm.juno.server.RestServlet} is nothing but a specialized {@link javax.servlet.http.HttpServlet}, and the
			{@link com.ibm.juno.server.RestRequest} and {@link com.ibm.juno.server.RestResponse} classes are nothing more than specialized {@link javax.servlet.http.HttpServletRequest} and 
			{@link javax.servlet.http.HttpServletResponse} objects.  
		This allows maximum flexibility for the developer since you can let Juno handle operations such as serialization, or you can revert 
			to the existing servlet APIs to do low-level processing of requests yourself.	
		It also means you need nothing more than a Servlet container such as Jetty to use the REST framework.
	</p>
	<h6 class='topic'>Features</h6>
	<ul>
		<li>Serializes POJOs to JSON, XML, HTML, URL-Encoding, UON, RDF/XML, N-Triple, Turtle, N3, SOAP, or Java-serialized-object based on
			value of <l>Accept</l> header.  <br>
			No user code is required to handle these types.
			<br>
			<ul>
				<li>Extensible design that provides ability to override existing content type handlers, or add the ability to handle other kinds of content types.
			</ul>
			<br>
		<li>Parses content of POST/PUT request bodies to POJOs.
			<br><br>
		<li>Automatic built-in ability to serialize POJO metadata to JSON+SCHEMA, XML+SCHEMA, or HTML+SCHEMA based on <l>Accept</l> header.
			<br><br>
		<li>Automatic negotiation of output Writer based on HTTP headers.
			<br>
			<ul>
				<li>Automatic handling of <l>Accept-Charset</l> header for all character sets supported by the JVM.
				<li>Automatic handling of <l>Accept-Encoding</l> header with registered encoders.
			</ul>
			<br>
		<li>Automatic error handling.
			<br>
			<ul>
				<li>Automatic 401 errors (Unauthorized) on failed guards.
				<li>Automatic 404 errors (Not Found) on unmatched path patterns.
				<li>Automatic 405 errors (Method Not Implemented) on unimplemented methods.
				<li>Automatic 406 errors (Not Acceptable) when no matching serializer was found to handle the <l>Accept</l> header.
				<li>Automatic 412 errors (Precondition Failed) when all matchers failed to match.
				<li>Automatic 415 errors (Unsupported Media Type) when no matching parser was found was found to handle the <l>Content-Type</l> header.
				<li>Automatic 500 errors on uncaught exceptions.
			</ul>
			<br>
		<li>Self-documenting REST interfaces.
			<br>
		<li>Various useful debugging features that make debugging using a browser extremely simple...
			<br>
			<ul>
				<li>Ability to pass HTTP header values as URL GET parameters (e.g. <l>&amp;Accept=text/xml</l>).
				<li>Ability to pass HTTP content on PUT/POST requests as a URL GET parameter (e.g. <l>&amp;content={foo:"bar"}</l>).
				<li>Ability to simulate non-GET requests using a <l>&amp;method</l> GET parameter (e.g. <l>&amp;method=POST</l>).
				<li>Ability to force <ss>"text/plain"</ss> on response using GET parameter <l>&amp;plainText=true</l>.
			</ul>
			<br>
		<li>Ability to implement overloaded HTTP methods through the use of the <l>&amp;method</l> attribute (e.g. <l>&amp;method=FOO</l>).
			<br><br>
		<li>Ability to match URL patterns (e.g. <l>/foo/{fooId}/bar/{barId}</l>) against URLs (e.g. <l>/foo/123/bar/456/bing</l>).
			<br><br>
		<li>Ability to associate guards at the resource or method levels through annotations.<br>
			Typically useful for security, but can be used for a variety of purposes.
			<br><br>
		<li>Ability to associate converters at the resource or method levels through annotations.<br>
			Typically useful for performing conversions on input and output, such as for supporting older input and output formats.
	</ul>
	<p>
		Many of the examples in this document are pulled directly from the <l>microservice-samples-project.zip</l> project.
	</p>
</div>
	
<!-- ======================================================================================================== -->
<a name="HelloWorldResource"></a>
<h2 class='topic' onclick='toggle(this)'>2 - Hello World Example</h2>
<div class='topic'>
	<p>
		A REST resource is an implementation of {@link com.ibm.juno.server.RestServlet}, which itself is simply an extension of {@link javax.servlet.http.HttpServlet}.  
	</p>
	<p>
		In this example, we define a resource called <l>HelloWorldResource</l>.  
		This example is located in the <l>microservice-samples-project.zip</l> project.
		It's assumed the reader is familiar with defining servlets in web applications.
	</p>
	<p>
		Like any servlet, we could define our resource in the <l>web.xml</l> file of the web application like so...
	</p>
	<p class='bcode'>
	<xt>&lt;?xml</xt> <xa>version</xa>=<xs>"1.0"</xs> <xa>encoding</xa>=<xs>"UTF-8"</xs><xt>?&gt;</xt>
	<xt>&lt;web-app</xt> <xa>version</xa>=<xs>"2.3"</xs><xt>&gt;</xt>
		<xt>&lt;servlet&gt;</xt>
			<xt>&lt;servlet-name&gt;</xt>HelloWorldResource<xt>&lt;/servlet-name&gt;</xt>
			<xt>&lt;servlet-class&gt;</xt>com.ibm.sample.HelloWorldResource<xt>&lt;/servlet-class&gt;</xt>
		<xt>&lt;/servlet&gt;</xt>
		<xt>&lt;servlet-mapping&gt;</xt>
			<xt>&lt;servlet-name&gt;</xt>HelloWorldResource<xt>&lt;/servlet-name&gt;</xt>
			<xt>&lt;url-pattern&gt;</xt>/*<xt>&lt;/url-pattern&gt;</xt>
		<xt>&lt;/servlet-mapping&gt;</xt>
	<xt>&lt;/web-app&gt;</xt>
	</p>
	<p>
		Our servlet code is shown below:
	</p>
	<p class='bcode'>
	<jd>/** 
	 * Sample REST resource that prints out a simple "Hello world!" message.
	 */</jd>
	<ja>@RestResource</ja>(
		messages=<js>"nls/HelloWorldResource"</js>, 
		properties={
			<ja>@Property</ja>(name=<jsf>HTMLDOC_links</jsf>, value=<js>"{up:'$R{requestParentURI}',options:'?method=OPTIONS'}"</js>)
		}
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> Resource {
	
		<jd>/** GET request handler */</jd>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>)
		<jk>public</jk> String sayHello() {
			<jk>return</jk> <js>"Hello world!"</js>;
		}
	}
	</p>
	<p>
		The <l>messages</l> annotation points to a properties file on the classpath whose contents are shown below:
	</p>
	<p class='bcode'>
	<cc>#--------------------------------------------------------------------------------
	# HelloWorldResource labels
	#--------------------------------------------------------------------------------</cc>
	<ck>label</ck> = <cv>Hello World sample resource</cv>
	<ck>description</ck> = <cv>Simplest possible resource</cv>
	<ck>sayHello</ck> = <cv>Responds with "Hello world!"</cv> 
	</p>	
	<p>
		It doesn't much simpler than that.  
		In this case, we're simply returning a string that will be converted to any of the supported languages (e.g. JSON, XML, HTML, ...).
		However, we could have returned any POJO consisting of beans, maps, collections, etc...
	</p>
	<p>
		The {@link com.ibm.juno.server.RestServletDefault} class that we're using here is a subclass of {@link com.ibm.juno.server.RestServlet} that provides default support for a variety of content types.  
		Implementers can choose to use this class, or create their own subclass of {@link com.ibm.juno.server.RestServlet} with their own specialized serializers and parsers.
	</p>
	<p>
		If you were to start up this servlet and view it with a browser, you would see this:
	</p>
	<img class='bordered' src="doc-files/HelloWorldResource1.png">
	<p>
		The Juno REST interface is designed to make it easy to interact with resources using nothing but a browser.  
		Therefore, several built-in features are provided for making it easy to do so.  
		Specifically, we'll be using these available URL parameters...
	</p>
	<ul class='normal'>
		<li><l>&amp;plainText=true</l> - If specified, then the <l>Content-Type</l> on the response is always <l>"text/plain"</l> regardless of the data format.
			<br><br>
		<li><l>&amp;Accept=X</l> - Specify the content type of the response.  
			In a browser, <l>"text/html"</l> is the default content type, but this parameter can be used to override the content type on the response.<br>
			Note:  The behavior is identical to setting the <l>Accept</l> header on the request.  
			In fact, Juno allows ANY HTTP request headers to be specified as URL parameters for debugging purposes.
	</ul>
	<p>
		Using the <l>plainText</l> parameter, we can view the HTML as plain text...	  
	</p>
	<img class='bordered' src="doc-files/HelloWorldResource2.png">
	<p>
		You'll notice that the HTML view has a simple stylesheet associated with it to improve the look of the interface.  
		It is possible to specify your own stylesheet, but the default styles will usually suffice for most purposes. 
	</p>
	<p>
		When accessed through a browser, the content type will default to HTML (based on the value of the <l>Accept</l> HTTP header).  
	</p>
	<p>
		Let's use the <l>&amp;Accept</l> URL paramter to override the <l>Accept</l> HTTP header to view this servlet in other formats...
	</p>
	<p>
		In the case of <l>JSON</l>, we're serialize a single string, so it gets rendered as a JSON fragment....
	</p>
	<img class='bordered' src="doc-files/HelloWorldResource3.png">
	<p>
		...or as <l>XML</l>...
	</p>	
	<img class='bordered' src="doc-files/HelloWorldResource4.png">
	<p>
		...or any of the other supported languages.
	</p>
	<p>
		If you click the OPTIONS link on the page, you'll see the results from an <l>HTTP OPTIONS</l> request:	  
	</p>
	<img class='bordered' src="doc-files/HelloWorldResourceOptions.png">
	<p>
		The OPTIONS page is generated automatically by introspection of the class itself combined with
			labels in the messages properties file.
		It's composed of a POJO that gets serialized just like any other POJO.  
		Therefore, the POJO can be searialized to any of the supported languages, like JSON.	  
	</p>
	<img class='bordered' src="doc-files/HelloWorldResourceOptionsJson.png">
</div>
	
<!-- ======================================================================================================== -->
<a name="ClassHierarchy"></a>
<h2 class='topic' onclick='toggle(this)'>3 - Class Hierarchy</h2>
<div class='topic'>
	<p>
		The class hierarchy for the REST servlet class is shown below:
	</p>
	<ul class='javahierarchy'>
		<li class='a'>{@link javax.servlet.http.HttpServlet javax.servlet.http.HttpServlet} 
		<ul>
			<li class='a'>{@link com.ibm.juno.server.RestServlet com.ibm.juno.server.RestServlet}
				<br>Contains all the main logic.
			<ul>
				<li class='a'>{@link com.ibm.juno.server.RestServletDefault com.ibm.juno.server.RestServletDefault}
				<br>Provides a default set of serializers, parsers, options page, stylesheet, and other common settings.
				<br><b>Developers will typically subclass this when creating REST resources in JEE environments.</b> 
				<ul>
					<li class='a'>{@link com.ibm.juno.microservice.Resource com.ibm.juno.microservice.Resource}
					<br>Subclass intented to be used in REST microservices.
					<br><b>Developers will typically subclass this when creating microservices.</b> 
					<li class='a'>{@link com.ibm.juno.server.RestServletGroupDefault com.ibm.juno.server.RestServletGroupDefault}
					<br>A default implementation for "router" pages.
					<ul>
						<li class='a'>{@link com.ibm.juno.microservice.ResourceGroup com.ibm.juno.microservice.ResourceGroup}
						<br>Subclass intented to be used in REST microservices.
					</ul>
					<li class='c'>{@link com.ibm.juno.server.remoteable.RemoteableServlet com.ibm.juno.server.remoteable.RemoteableServlet}
					<br>REST servlet for implementing remoteable proxy interfaces.
				</ul>
				<li class='a'>{@link com.ibm.juno.server.jena.RestServletJenaDefault com.ibm.juno.server.jena.RestServletJenaDefault}
				<br>Same as {@link com.ibm.juno.server.RestServletDefault}, but adds RDF support.
				<ul>
					<li class='a'>{@link com.ibm.juno.microservice.ResourceJena com.ibm.juno.microservice.ResourceJena}
					<br>Subclass intented to be used in REST microservices.
					<li class='a'>{@link com.ibm.juno.server.jena.RestServletJenaGroupDefault com.ibm.juno.server.jena.RestServletJenaGroupDefault}
					<br>Same as {@link com.ibm.juno.server.RestServletGroupDefault}, but adds RDF support.
				</ul>
				<li class='a'><code>com.ibm.team.repository.service.JazzRestResource</code>
				<br>Parent class in Jazz Foundation for REST-based services.
				<ul>
					<li class='a'><code>com.ibm.team.repository.service.JazzDefaultRestResource</code>
					<br>Provides a default set of serializers, parsers, options page, stylesheet, and other common settings.
				</ul>
			</ul>
		</ul>
	</ul>
	<p>
		The servlets with RDF support require Jena on the classpath.  
		All other serializers and parsers do not have any external library dependencies.
		For this reason, we have separate servlets for supporting RDF so that you don't need Jena if you don't need to support RDF. 
	</p>
	<p>
		The {@link com.ibm.juno.server.RestRequest} and {@link com.ibm.juno.server.RestResponse} classes described later also extend from their servlet equivalents:
	</p> 
	<ul class='javahierarchy'>
		<li class='i'>{@link javax.servlet.http.HttpServletRequest javax.servlet.http.HttpServletRequest}
		<ul>
			<li class='c'>{@link com.ibm.juno.server.RestRequest com.ibm.juno.server.RestRequest} - Augmented with specialized REST methods.
		</ul> 
		<li class='i'>{@link javax.servlet.http.HttpServletResponse javax.servlet.http.HttpServletResponse}
		<ul>
			<li class='c'>{@link com.ibm.juno.server.RestResponse com.ibm.juno.server.RestResponse} - Augmented with specialized REST methods.
		</ul> 
	</ul>
</div>

	<!-- ======================================================================================================== -->
<a name="RestResources"></a>
<h2 class='topic' onclick='toggle(this)'>4 - REST Servlets</h2>
	<div class='topic'>
		<p>
		Since REST servlets are subclasses of <l>HttpServlet</l>, they can be deployed in a J2EE
			container like any other servlet, typically inside a <l>web.xml</l> file.
		The REST servlet framework does not depend on any classloader scanning or external setup
			other than registering the servlet with the J2EE container.
		</p>
		<p>
		REST servlets can also be deployed by declaring them as children of other REST servlets (described later).
		</p>
		<p>
 		A REST servlet consists of an instance of {@link com.ibm.juno.server.RestServlet} 
 			annotated with {@link com.ibm.juno.server.annotation.RestResource @RestResource} containing
			public Java methods annotated with {@link com.ibm.juno.server.annotation.RestMethod @RestMethod}.
		</p>
		<p>
		Developers will typically subclass directly from {@link com.ibm.juno.server.RestServletDefault}
			since it provides a default set of serializers and parsers for a variety of 
			<l>Accept</l> and <l>Content-Type</l> types.
		</p>
	<h6 class='figure'>Valid Accept headers for RestServletDefault</h6>
	<table class='styled'>
		<tr>
			<th>Accept</th>
			<th>Content-Type</th>
			<th>Serializer</th>
		</tr>
		<tr>
			<td class='code'>application/json<br>text/json</td>
			<td class='code'>application/json</td>
			<td>{@link com.ibm.juno.core.json.JsonSerializer}</td>
		</tr>
		<tr>
			<td class='code'>application/json+simple<br>text/json+simple</td>
			<td class='code'>application/json</td>
			<td>{@link com.ibm.juno.core.json.JsonSerializer.Simple}</td>
		</tr>
			<td class='code'>application/json+schema<br>text/json+schema</td>
			<td class='code'>application/json</td>
			<td>{@link com.ibm.juno.core.json.JsonSchemaSerializer}</td>
		</tr>
		<tr>
			<td class='code'>text/xml</td>
			<td class='code'>text/xml</td>
			<td>{@link com.ibm.juno.core.xml.XmlDocSerializer}</td>
		</tr>
		<tr>
			<td class='code'>text/xml+schema</td>
			<td class='code'>text/xml</td>
			<td>{@link com.ibm.juno.core.xml.XmlSchemaDocSerializer}</td>
		</tr>
		<tr>
			<td class='code'>text/html</td>
	 		<td class='code'>text/html</td>
			<td>{@link com.ibm.juno.core.html.HtmlDocSerializer}</td>
		</tr>
		<tr>
			<td class='code'>text/html+stripped</td>
			<td class='code'>text/html</td>
			<td>{@link com.ibm.juno.core.html.HtmlStrippedDocSerializer}</td>
		</tr>
		<tr>
			<td class='code'>text/uon</td>
			<td class='code'>text/uon</td>
			<td>{@link com.ibm.juno.core.urlencoding.UonSerializer}</td>
		</tr>
		<tr>
			<td class='code'>text/uon-simple</td>
	 		<td class='code'>text/uon</td>
	 		<td>{@link com.ibm.juno.core.urlencoding.UonSerializer.Simple}</td>
		</tr>
		<tr>
			<td class='code'>application/x-www-form-urlencoded</td>
			<td class='code'>application/x-www-form-urlencoded</td>
			<td>{@link com.ibm.juno.core.urlencoding.UrlEncodingSerializer}</td>
		</tr>
		<tr>
	 		<td class='code'>application/x-www-form-urlencoded-simple</td>
	 		<td class='code'>application/x-www-form-urlencoded</td>
			<td>{@link com.ibm.juno.core.urlencoding.UrlEncodingSerializer.Simple}</td>
		</tr>
		<tr>
			<td class='code'>text/xml+soap</td>
			<td class='code'>text/xml</td>
			<td>{@link com.ibm.juno.core.soap.SoapXmlSerializer}</td>
		</tr>
		<tr>
			<td class='code'>text/plain</td>
			<td class='code'>text/plain</td>
			<td>{@link com.ibm.juno.core.plaintext.PlainTextSerializer}</td>
		</tr>
		<tr>
			<td class='code'>application/x-java-serialized-object</td>
			<td class='code'>application/x-java-serialized-object</td>
			<td>{@link com.ibm.juno.core.jso.JavaSerializedObjectSerializer}</td>
		</tr>
	</table>
	<h6 class='figure'>Valid Content-Type headers for RestServletDefault</h6>
	<table class='styled'>
		<tr>
			<th>Content-Type</th>
			<th>Parser</th>
		</tr>
		<tr>
			<td class='code'>application/json<br>text/json</td>
			<td>{@link com.ibm.juno.core.json.JsonParser}</td>
		</tr>
		<tr>
			<td class='code'>text/xml<br>application/xml</td>
			<td>{@link com.ibm.juno.core.xml.XmlParser}</td>
		</tr>
		<tr>
			<td class='code'>text/html<br>text/html+stripped</td>
			<td>{@link com.ibm.juno.core.html.HtmlParser}</td>
		</tr>
		<tr>
			<td class='code'>text/uon</td>
			<td>{@link com.ibm.juno.core.urlencoding.UonParser}</td>
		</tr>
		<tr>
			<td class='code'>application/x-www-form-urlencoded</td>
			<td>{@link com.ibm.juno.core.urlencoding.UrlEncodingParser}</td>
		</tr>
		<tr>
			<td class='code'>text/plain</td>
			<td>{@link com.ibm.juno.core.plaintext.PlainTextParser}</td>
		</tr>
	</table>
	<p>
 		{@link com.ibm.juno.server.RestServletDefault} also provides a default OPTIONS page by implementing 
 			a {@link com.ibm.juno.server.RestServletDefault#getOptions(RestRequest)} method that returns a POJO consisting
 			of beans describing the class.
 		This is what produces the output for the OPTIONS page on the Hello World sample above.
		</p>
	
	<h6 class='topic'>Additional Information</h6>
	<ul class='javahierarchy'>
		<li class='a'>{@link com.ibm.juno.server.RestServletDefault}
		<li class='a'>{@link com.ibm.juno.server.jena.RestServletJenaDefault}	
	</ul>

	<!-- ======================================================================================================== -->
	<a name="RestResources.MethodSignature"></a>
	<h3 class='topic' onclick='toggle(this)'>4.1 - REST Java Method Signature</h3>
	<div class='topic'>
		<p>
			REST Java methods are identified on REST servlets using the {@link com.ibm.juno.server.annotation.RestMethod @RestMethod} annotation. 
			The annotation allows the framework to identify the available REST methods through reflection.
		</p>
		<p class='bcode'>
		<jd>/** GET request handler */</jd>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>)
	<jk>public</jk> String sayHello() {
		<jk>return</jk> <js>"Hello world!"</js>;
	}
		</p>
		<h6 class='topic'>Method Name</h6>
		<p>
			There are no restrictions on the name of the Java method.  However, if you plan on making use of the 
				{@link com.ibm.juno.server.annotation.RestResource#messages() @RestResource.messages()} 
				annotation (described later), the method names must be unique to make it possible to identify unique keys for labels in the resource bundle.
			Therefore, you should not define two identically-named <l>doFoo(...)</l> methods that differ only by parameters.
			If you're not using messages for NLS support, then name them whatever you want!
		</p>
		<h6 class='topic'>Method Return Type</h6>
		<p>
			The return type can be any serializable POJO as defined in <a class='doclink' href='../../../../overview-summary.html#Core.PojoCategories'>POJO Categories</a>.
			It can also be <jk>void</jk> if the method is not sending any output (e.g. a request redirect) or
				is setting the output using the {@link com.ibm.juno.server.RestResponse#setOutput(Object)} method.
			Calling the {@link com.ibm.juno.server.RestResponse#setOutput(Object)} method is functionally equivalent to returning a value.
		</p>
		<p class='bcode'>
	<jc>// Equivalent method 1</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>)
	<jk>public void</jk> doGet(RestResponse res) {
		res.setOutput(<js>"Hello World!"</js>);
	}

 	<jc>// Equivalent method 2</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>)
	<jk>public</jk> String doGet() {
		<jk>return</jk> <js>"Hello World!"</js>;
	}
		</p>
		<p>
			The return type can also be any of the following special object types:
		</p>
		<ul class='javahierarchy'>
			<li class='c'>{@link java.io.InputStream}
				<br>The contents are simply piped to the output stream returned by {@link com.ibm.juno.server.RestResponse#getNegotiatedOutputStream()}.
				<br>Note that you should call {@link com.ibm.juno.server.RestResponse#setContentType(String)} to set the <l>Content-Type</l> header if you use this object type.
			<li class='c'>{@link java.io.Reader}
				<br>The contents are simply piped to the output stream returned by {@link com.ibm.juno.server.RestResponse#getNegotiatedWriter()}.
				<br>Note that you should call {@link com.ibm.juno.server.RestResponse#setContentType(String)} to set the <l>Content-Type</l> header if you use this object type.
			<li class='c'>{@link com.ibm.juno.server.Redirect}
				<br>Represents an HTTP redirect response.
			<li class='i'>{@link com.ibm.juno.core.Streamable}
				<br>Interface that identifies that an object can be serialized directly to an output stream.
			<li class='i'>{@link com.ibm.juno.core.Writable}
				<br>Interface that identifies that an object can be serialized directly to a writer.
			<li class='c'>{@link com.ibm.juno.core.utils.ZipFileList}
				<br>Special interface for sending zip files as responses.
		</ul>
		<p>
			Additional "special types" can be defined through the {@link com.ibm.juno.server.ResponseHandler} interface (described later).
		</p>
		<h6 class='topic'>Method Parameters</h6>
		<p>
			The method can contain any of the following parameters in any order:
		</p>
		<ul class='spaced-list'>
			<li>Parameter of type {@link com.ibm.juno.server.RestRequest}
			<li>Parameter of type {@link javax.servlet.http.HttpServletRequest}
			<li>Parameter of type {@link com.ibm.juno.server.RestResponse}
			<li>Parameter of type {@link javax.servlet.http.HttpServletResponse}
			<li>Parameters annotated with {@link com.ibm.juno.server.annotation.Attr @Attr}
				<br>These match variables in matched URL path patterns.
			<li>Parameters annotated with with {@link com.ibm.juno.server.annotation.Param @Param}
				<br>These denote query parameter values.
			<li>Parameters annotated with {@link com.ibm.juno.server.annotation.HasParam @HasParam}
				<br>Similar to <ja>@Param</ja>, but resolves to a simple boolean <jk>true/false</jk> denoting whether the query parameter exists.
			<li>Parameters annotated with {@link com.ibm.juno.server.annotation.QParam @QParam} 
				<br>Same as <ja>@Param</ja>, but only looks for actual query parameters, not form post query parameters.
				<br>Using this prevents the HTTP body from being processed as a URL-Encoded form post.
			<li>Parameters annotated with {@link com.ibm.juno.server.annotation.HasQParam @HasQParam}
				<br>Similar to <ja>@QParam</ja>, but resolves to a simple boolean <jk>true/false</jk> denoting whether the query parameter exists.
			<li>Parameters annotated with {@link com.ibm.juno.server.annotation.Header @Header}
				<br>These denote header values.
			<li>Parameter annotated with {@link com.ibm.juno.server.annotation.Method @Method} 
				<br>This denotes the HTTP method name.
			<li>Parameter annotated with {@link com.ibm.juno.server.annotation.PathRemainder @PathRemainder}
				<br>This denotes the path remainder value after path pattern match.
			<li>Parameter annotated with {@link com.ibm.juno.server.annotation.Content @Content} 
				<br>This denotes the HTTP content parsed as a POJO.
				<br>The type can be any parsable POJO type as defined in <a class='doclink' href='../../../../overview-summary.html#Core.PojoCategories'>POJO Categories</a>
			<li>Parameter annotated with {@link com.ibm.juno.server.annotation.Messages @Messages} 
				<br>This gives you access to the resource bundle for the servlet localized to the language on the request.
			<li>Parameter annotated with {@link com.ibm.juno.server.annotation.Properties @Properties} 
				<br>This gives you access to the serializer/parser/servlet properties so they can be read or altered on the request.
		</ul>
		<p class='bcode'>
	<jc>// Example GET request using annotated attributes</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example1/{a1}/{a2}/{a3}/*"</js>)
	<jk>public</jk> String doGetExample1(
		RestRequest req,
		RestResponse res,
		<ja>@Method</ja> String method,
		<ja>@Attr</ja> String a1,
		<ja>@Attr</ja> <jk>int</jk> a2,
		<ja>@Attr</ja> UUID a3,
		<ja>@Param</ja>(<js>"p1"</js>) <jk>int</jk> p1,
		<ja>@Param</ja>(<js>"p2"</js>) String p2,
		<ja>@Param</ja>(<js>"p3"</js>) UUID p3,
		<ja>@HasParam</ja>(<js>"p3"</js>) boolean hasP3,
		<ja>@PathRemainder</ja> String remainder,
		<ja>@Header</ja>(<js>"Accept-Language"</js>) String lang,
		<ja>@Header</ja>(<js>"Accept"</js>) String accept,
		<ja>@Header</ja>(<js>"DNT"</js>) <jk>int</jk> doNotTrack,
		<ja>@Properties</ja> ObjectMap properties,
		<ja>@Messages</ja> ResourceBundle nls
	) {
		<jc>// Do something with all of those</jc>
	}
		</p>
		<p>
			All the annotated parameters (with the exception of <l>@Content</l>) can be any POJO type convertable from a <l>String</l>.
			(See <a class='doclink' href='#PojosConvertableFromString'>POJOs Convertable From String</a>)
		</p>
		<p>
			For example, headers can be accessed as Strings or UUIDs...
		</p>
		<p class='bcode'>
	<jc>// Example GET with access to HTTP headers</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>)
	<jk>public</jk> String doGet(<ja>@Header</ja>(<js>"Accept-Language"</js>) String lang, <ja>@Header</ja>(<js>"ETag"</js>) UUID eTag) <jk>throws</jk> Exception {
		...
	}
		</p>
		<p>
			All annotations have programmatic equivalents on the {@link com.ibm.juno.server.RestRequest} class:
		</p>
		<ul class='javahierarchy'>
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getAttribute(String,Class)}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getParameter(String,Class)}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#hasParameter(String)}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getQueryParameter(String,Class)}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#hasQueryParameter(String)}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getInput(Class)}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getHeader(String,Class)}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getMethod()}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getPathRemainder()}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getMessage(String,Object[])}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getProperties()}
		</ul>
		
		<!-- ======================================================================================================== -->
		<a name="RestResources.MethodSignature.Path"></a>
		<h4 class='topic' onclick='toggle(this)'>4.1.1 - Path</h4>
		<div class='topic'>
			<p>
				The {@link com.ibm.juno.server.annotation.RestMethod#path() @RestMethod.path()} annotation 
					allows you to define URL path patterns to match against.
				These patterns can contain variables of the form <l>"{xxx}"</l> that can be passed in directly to the
					Java methods as extra parameters.
		</p>
		<p>
				In the following example, 3 separate GET request handlers are defined with different path patterns.
				Note how the variables are passed in as additional arguments on the method, and how those arguments are automatically
					converted to the specified class type...
		</p>
		<p class='bcode'>
	<jc>// Default method</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>)
	<jk>public void</jk> doGetDefault() {
		...
	}

	<jc>// Method with path pattern</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/xxx"</js>)
	<jk>public void</jk> doGetNoArgs(...) {
		...
	}

	<jc>// Method with path pattern with arguments</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/xxx/{foo}/{bar}/{baz}/{bing}"</js>)
	<jk>public void</jk> doGetWithArgs(<ja>@Attr</ja> String foo, <ja>@Attr</ja> <jk>int</jk> bar, <ja>@Attr</ja> MyEnum baz, <ja>@Attr</ja> UUID bing) {
		...
	}
		</p>
		<p>
				By default, path patterns are matched using a best-match heuristic. 
				When overlaps occur, URLs are matched from most-specific to most-general order:
		</p>
		<p class='bcode'>
	<jc>// Try first </jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/foo/bar"</js>)
	<jk>public void</jk> method1() {
		...
	}

	<jc>// Try second</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/foo/{bar}"</js>)
	<jk>public void</jk> method2(...) {
		...
	}

	<jc>// Try third</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/foo/*"</js>)
	<jk>public void</jk> method3(...) {
		...
	}

	<jc>// Try last</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>)
	<jk>public void</jk> method4(...) {
		...
	}
		</p>
		<p>
				The match heuristic behavior can be overridden by the {@link com.ibm.juno.server.annotation.RestMethod#priority() @RestMethod.priority()} annotation property.
				However, in practice this is almost never needed.
		</p>
		<p>
				Paths that end with <js>"/*"</js> will do a prefix match on the incoming URL.  
				Any remainder after the match can be accessed through {@link com.ibm.juno.server.RestRequest#getPathRemainder()} 
					or parameters with the {@link com.ibm.juno.server.annotation.PathRemainder @PathRemainder} annotation.
				On the other hand, paths that don't end with <js>"/*"</js> (e.g. <js>"/"</js> or <js>"/foo"</js>) will require
					an exact URL match, and if any remainder exists, a 404 (not found) error will be thrown.
		</p>
		<p>
				The following example shows the distinction.
			</p>
			<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>)
	<jk>public void</jk> doGet(<ja>@PathRemainder</ja> String remainder) {
		<jc>// URL path pattern can have remainder accessible through req.getRemainder().</jc>
	}

	<ja>@RestMethod</ja>(name=<js>"PUT"</js>, path=<js>"/"</js>)
	<jk>public void</jk> doPut() {
		<jc>// URL path pattern must match exactly and will cause a 404 error if a remainder exists.</jc>
	}
		</p>
		<p>
				Annotations are provided for easy access to URL parameters with automatic conversion to any parsable object type.
				For example, the following example can process the URL <l>"/urlWithParams?foo=foo&amp;bar=[1,2,3]&amp;baz=067e6162-3b6f-4ae2-a171-2470b63dff00"</l>...
			</p>
			<p class='bcode'>
	<jc>// Example GET request with access to query parameters</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/urlWithParams"</js>)
	<jk>public</jk> String doGetWithParams(<ja>@Param</ja>(<js>"foo"</js>) String foo, <ja>@Param</ja>(<js>"bar"</js>) <jk>int</jk> bar, <ja>@Param</ja>(<js>"baz"</js>) UUID baz) <jk>throws</jk> Exception {
		<jk>return</jk> <js>"GET /urlWithParams?foo="</js>+foo+<js>"&amp;bar="</js>+bar+<js>"&amp;baz="</js>+baz);
	}
		</p>
		</div>
		
		<!-- ======================================================================================================== -->
		<a name="RestResources.MethodSignature.Matchers"></a>
		<h4 class='topic' onclick='toggle(this)'>4.1.2 - Matchers</h4>
		<div class='topic'>
		<p>
				{@link com.ibm.juno.server.RestMatcher RestMatchers} are used to allow multiple Java methods to be tied to the same HTTP method and path, but
					differentiated by some request attribute such as a specific header value.
			<p class='bcode'>
	<jc>// GET method that gets invoked for administrators</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>, matchers=IsAdminMatcher.<jk>class</jk>)
	<jk>public</jk> Object doGetForAdmin() {
		...
	}

	<jc>// GET method that gets invoked for everyone else</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>)
	<jk>public</jk> Object doGetForEveryoneElse() {
		...
	}
		</p>
		<p>
				The interface for matchers is simple:
			</p>
			<p class='bcode'>
	<jk>public class</jk> IsAdminMatcher <jk>extends</jk> RestMatcher {
		<ja>@Override</ja>
		<jk>public boolean</jk> matches(RestRequest req) {
			<jk>return</jk> req.isUserInRole(<js>"ADMINS_GROUP"</js>);
		}
	}
		</p>
			<h6 class='topic'>Other Notes</h6>
			<ul class='spaced-list'>
				<li>If no methods are found with a matching matcher, a <l>412 Precondition Failed</l> status is returned.
				<li>If multiple matchers are specified on the same method, ONLY ONE matcher needs to match for the method to be invoked.
				<li>Note that you CANNOT define identical paths on different methods UNLESS you use matchers.
					<br>That includes paths that are only different in variable names (e.g. <l>"/foo/{bar}"</l> and <l>"/foo/{baz}"</l>).
					<br>If you try to do so, a <l>ServletException</l> will be thrown on startup.
				<li>Methods with matchers take precedence over methods without.
					<br>Otherwise, methods are attempted in the order they appear in the class.
			</ul>
	</div>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.RequestContent"></a>
	<h3 class='topic' onclick='toggle(this)'>4.2 - Request Content</h3>
	<div class='topic'>
		<p>
			Annotations are provided for easy access to HTTP body content as any parsable POJO type
			(See <a class='doclink' href='../../../../overview-summary.html#Core.PojoCategories'>POJO Categories</a>).
			In the example below, we're POSTing beans.
		</p>
		<p class='bcode'>
	<jc>// Example POST of a bean</jc>
	<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/"</js>)
	<jk>public void</jk> doPost(<ja>@Content</ja> Person person) <jk>throws</jk> Exception {
		<jc>// Do something with person.</jc>
	}
		</p>
		<p>
			The HTTP body of a request can be retrieved as a parsed POJO using either the 
				{@link com.ibm.juno.server.RestRequest#getInput(Class)} method, or a parameter 
				annotated with {@link com.ibm.juno.server.annotation.Content @Content}.
		</p>
		<p class='bcode'>
	<jc>// Equivalent method 1</jc>
	<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/example1"</js>)
	<jk>public void</jk> doPost1(<ja>@Content</ja> Person p) {
		<jc>// Do something with p.</jc>
	}

	<jc>// Equivalent method 2</jc>
	<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/example2"</js>)
	<jk>public void</jk> doPost2(RestRequest req) {
		Person p = req.getInput(Person.<jk>class</jk>);
		<jc>// Do something with p.</jc>
	}
		</p>
		<p>
			The Juno framework will automatically determine the appropriate <l>Parser</l> to use based on the 
			<l>Content-Type</l> HTTP header.  So the body content could be JSON or XML or any other supported parsing types.
		</p>
		
	<!-- ======================================================================================================== -->
		<a name="RestResources.RequestContent.FormPosts"></a>
		<h4 class='topic' onclick='toggle(this)'>4.2.1 - Form Posts</h4>
	<div class='topic'>	
		<p>
				URL-Encoded form posts require their own topic since they can be handled in multiple ways.
			</p>
			<p>
				The best way to handle a form post is by using an input bean.
				The samples include a <l>UrlEncodedFormResource</l> class that takes in URL-Encoded
					form post of the form <l>"aString=foo&aNumber=123&aDate=2001-07-04T15:30:45Z"</l>.
				The code is shown here:
		</p>
		<p class='bcode'>				
	<ja>@RestResource</ja>(
		path=<js>"/urlEncodedForm"</js>
	)
	<jk>public class</jk> UrlEncodedFormResource <jk>extends</jk> Resource {

		<jd>/** POST request handler */</jd>
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/"</js>)
		<jk>public</jk> Object doPost(<ja>@Content</ja> FormInputBean input) <jk>throws</jk> Exception {
			<jc>// Just mirror back the request</jc>
			<jk>return</jk> input;
		}
	
		<jk>public static class</jk> FormInputBean {
			<jk>public</jk> String <jf>aString</jf>;
			<jk>public int</jk> <jf>aNumber</jf>;
			<ja>@BeanProperty</ja>(filter=CalendarFilter.<jsf>ISO8601DT</jsf>.<jk>class</jk>)
			<jk>public</jk> Calendar <jf>aDate</jf>;
		}
	}		
		</p>	
		<p>
				Another possibility is to access the form parameters individually:	
			</p>	
			<p class='bcode'>
	<jd>/** POST request handler */</jd>
	<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/"</js>)
	<jk>public</jk> Object doPost(<ja>@Param</ja>(<js>"aString"</js>) String aString, <ja>@Param</ja>(<js>"aNumber"</js>) <jk>int</jk> aNumber, <ja>@Param</ja>(<js>"aDate"</js>) Calendar aDate) <jk>throws</jk> Exception {
		...
	}
		</p>
		<p>
				The advantage to the form input bean is that it can handle any of the parsable types (e.g. JSON, XML...) 
					in addition to URL-Encoding.  The latter approach only supports URL-Encoding.
			</p>
			<p class='severe'>
				If you're using form input beans, DO NOT use the <l>@Param</l> attribute
					or {@link com.ibm.juno.server.RestRequest#getParameter(String)} method since this will
					cause the underlying JEE servlet to parse the HTTP body as a form post.
				Your input bean will end up being null since there won't be any content left
					after the servlet has parsed the body of the request.
				This applies to WHENEVER you use <l>@Content</l> or {@link com.ibm.juno.server.RestRequest#getInput(Class)}.
		</p>	
		</div>

		<!-- ======================================================================================================== -->
		<a name="RestResources.RequestContent"></a>
		<h4 class='topic' onclick='toggle(this)'>4.2.2 - Multipart Form Posts</h4>
		<div class='topic'>
		<p>
				The Juno framework does not natively support multipart form posts.  
				However, it can be used in conjunction wih the Apache Commons File Upload library to do so.
		</p>	
		<p>
				The samples include a <l>TempDirResource</l> class that uses the File Upload library
					to allow files to be uploaded as multipart form posts.
			</p>
			<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/tempDir"</js>
	)
	<jk>public class</jk> TempDirResource <jk>extends</jk> DirectoryResource {
	
		<jd>/**
		 * [POST /upload] - Upload a file as a multipart form post.
		 * Shows how to use the Apache Commons ServletFileUpload class for handling multi-part form posts.
		 */</jd>
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/upload"</js>, matchers=TempDirResource.MultipartFormDataMatcher.<jk>class</jk>)
		<jk>public</jk> Redirect uploadFile(RestRequest req) <jk>throws</jk> Exception {
			ServletFileUpload upload = <jk>new</jk> ServletFileUpload();
			FileItemIterator iter = upload.getItemIterator(req);
			<jk>while</jk> (iter.hasNext()) {
				FileItemStream item = iter.next();
				<jk>if</jk> (item.getFieldName().equals(<js>"contents"</js>)) { 
					File f = <jk>new</jk> File(getRootDir(), item.getName());
					IOPipe.<jsm>create</jsm>(item.openStream(), <jk>new</jk> FileOutputStream(f)).closeOut().run();
				}
			}
			<jk>return new</jk> Redirect(); <jc>// Redirect to the servlet root.</jc>
		}
	
		<jd>/** Causes a 404 if POST isn't multipart/form-data */</jd>
		<jk>public static class</jk> MultipartFormDataMatcher <jk>extends</jk> RestMatcher {
			<ja>@Override</ja> <jc>/* RestMatcher */</jc>
			<jk>public boolean</jk> matches(RestRequest req) {
				String contentType = req.getContentType();
				<jk>return</jk> contentType != <jk>null</jk> && contentType.startsWith(<js>"multipart/form-data"</js>); 
			}
		}
		</p>
		</div>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.ResponseContent"></a>
	<h3 class='topic' onclick='toggle(this)'>4.3 - Response Content</h3>
	<div class='topic'>
		<p>
			REST Java methods can generate output in any of the following ways:
		</p>
		<ul class='spaced-list'>
			<li>By returning a serializable POJO, or any of the following:
				<br>{@link java.io.Reader}, {@link java.io.InputStream}, {@link com.ibm.juno.core.Streamable}, {@link com.ibm.juno.core.Writable} 
			<li>By calling {@link com.ibm.juno.server.RestResponse#setOutput(Object)} with any of the types above.
			<li>By accessing the {@link java.io.Writer} directly by calling {@link com.ibm.juno.server.RestResponse#getNegotiatedWriter()} and writing the output
				yourself.
		</ul>
		<p class='bcode'>
	<jc>// Equivalent method 1</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example1/{personId}"</js>)
	<jk>public</jk> Person doGet1(<ja>@Attr</ja> UUID personId) {
		Person p = getPersonById(personId);
		<jk>return</jk> p;
	}

	<jc>// Equivalent method 2</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example2/{personId}"</js>)
	<jk>public void</jk> doGet2(RestResponse res, <ja>@Attr</ja> UUID personId) {
		Person p = getPersonById(personId);
		res.setOutput(p);
	}

	<jc>// (Sorta) Equivalent method 3</jc>
	<jc>// (Ignores any converters or method-level properties)</jc>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/example3/{personId}"</js>)
	<jk>public void</jk> doGet3(RestRequest req, RestResponse res, <ja>@Attr</ja> UUID personId) {
		Person p = getPersonById(personId);
		String accept = req.getHeader(<js>"Accept"</js>, <js>"text/json"</js>);
		WriterSerializer s = res.getSerializerGroup().getWriterSerializer(accept);
		res.setContentType(s.getResponseContentType());
		s.serialize(p, res.getNegotiatedWriter());
	}
		</p>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.OptionsPages"></a>
	<h3 class='topic' onclick='toggle(this)'>4.4 - OPTIONS Pages</h3>
	<div class='topic'>
		<p>
			One of the most useful features of Juno is that it can produce OPTIONS pages for self-documenting designs (i.e. REST interfaces that document themselves).
		</p>
		<h6 class='figure'>OPTIONS page for HelloWorld sample resource</h6>
	 	<img class='bordered' src='doc-files/OptionsPage.png'>
		<p>
			To facilitate this, the {@link com.ibm.juno.server.labels.ResourceOptions} class is provided that 
				inspects a <l>RestServlet</l> and its methods, and returns a serializable POJO data structure
				that describes the options for that resource and pulling localized strings from the resource
				bundle associated with the servlet.
		</p>
		<p>
	 		{@link com.ibm.juno.server.RestServletDefault} provides a default OPTIONS page by implementing 
	 			a {@link com.ibm.juno.server.RestServletDefault#getOptions(RestRequest)} method that returns a POJO consisting
	 			of beans describing the class.
	 	</p>
	 	<p class='bcode'>
	<jd>/**
	 * [OPTIONS /*] - Show resource options.
	 *
	 * <ja>@param</ja> req The HTTP request.
	 * <ja>@return</ja> A bean containing the contents for the OPTIONS page.
	 */</jd>
	<ja>@RestMethod</ja>(name=<js>"OPTIONS"</js>, path=<js>"/*"</js>,
		properties={
			<ja>@Property</ja>(name=<jsf>HTMLDOC_links</jsf>, value=<js>"{back:'$R{servletURI}'}"</js>),
			<ja>@Property</ja>(name=<jsf>HTMLDOC_description</jsf>, value=<js>"Resource options"</js>)
		},
		description=<js>"Resource options"</js>
	)
	<jk>public</jk> ResourceOptions getOptions(RestRequest req) {
		<jk>return new</jk> ResourceOptions(<jk>this</jk>, req);
	}
	 	</p>
	 	<p>
	 		The <l>AddressBookResource</l> class in the samples shows an example of augmenting the existing 
	 			{@link com.ibm.juno.server.labels.ResourceOptions} bean with some additional information.
		</p>
		<p class='bcode'>
	<jd>/** OPTIONS request handler */</jd>
	<ja>@Override</ja> <jc>/* RestServletJenaDefault */</jc>
	<ja>@RestMethod</ja>(name=<js>"OPTIONS"</js>, path=<js>"/*"</js>)
	<jk>public</jk> ResourceOptions getOptions(RestRequest req) {
		<jk>return new</jk> Options(req);
	}			

	<jd>/**
	 * Output POJO for OPTIONS requests.
	 * Note that we're extending the existing ResourceOptions class.
	 */</jd>
	<jk>public class</jk> Options <jk>extends</jk> ResourceOptions {
		<jk>public</jk> ParamDescription[] queryableParameters;
		<jk>public</jk> String[] otherNotes;

		<jk>public</jk> Options(RestRequest req) {
			<jk>super</jk>(AddressBookResource.<jk>this</jk>, req);
			Locale locale = req.getLocale();
			queryableParameters = getQueryableParamDescriptions(locale);
			otherNotes = getMessage(locale, <js>"otherNotes"</js>).split(<js>"\\.\\s*"</js>);
		}
	}
	 	</p>
	 	<p>
	 		Refer to <a class='doclink' href='#AddressBookResource'>Address Book Resource</a> for a complete example.
	 	</p>
	 	<h6 class='topic'>Label and Description</h6>
	 	<p>
	 		The label and description can be defined in two ways.
	 	</p>
		<p>
	 		If you don't care about internationalization, then the easiest way is to use annotations on the servlet.
	 	</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/example"</js>,
		label=<js>"Example Resource"</js>,
		description=<js>"This shows how to use labels and descriptions."</js>
	)
	<jk>public class</jk> ExampleResource <jk>extends</jk> RestServletDefault {
		</p>	 	
		<p>
			The second approach which supports internationalization is to use the 
				{@link com.ibm.juno.server.annotation.RestResource#messages() @RestResource.messages()}
				annotation to point to a resource bundle, and then use predefined properties
				that identify the label and description.
		</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		messages=<js>"nls/Messages"</js>
	)
	<jk>public class</jk> ExampleResource <jk>extends</jk> RestServletDefault {
		</p>	 	
		<p>
			The label and description are specified as special properties in the resource bundle:
		</p>
		<p class='bcode'>
	<cc>#--------------------------------------------------------------------------------
	# Contents of Messages.properties
	#--------------------------------------------------------------------------------</cc>
	<ck>label</ck> = <cv>Example Resource</cv>
	<ck>description</ck> = <cv>This shows how to use labels and descriptions.</cv>
		</p>	 	
		<p>
			Message keys can optionally be prefixed by the short class name if the resource bundle is shared by multiple servlets:
		</p>
		<p class='bcode'>
	<cc>#--------------------------------------------------------------------------------
	# Contents of Messages.properties
	#--------------------------------------------------------------------------------</cc>
	<ck>ExampleResource.label</ck> = <cv>Example Resource</cv>
	<ck>ExampleResource.description</ck> = <cv>This shows how to use labels and descriptions.</cv>
		</p>	 	
	 	<p>
	 		When both annotations and properties are used, annotations take precedence.
	 	</p>
	 	<p>
	 		The localized label and description are also available through the following methods:
		</p>
	 	<ul class='javahierarchy'>
	 		<li class='m'>{@link com.ibm.juno.server.RestRequest#getServletLabel()}
	 		<li class='m'>{@link com.ibm.juno.server.RestRequest#getServletDescription()}
	 	</ul>
		<p>
	 		They are also made available as the request string variables <js>"$R{servletLabel}"</js> and <js>"$R{servletDescription}"</js>.
	 		These variable facilitate the localized label and descriptions on the HTML pages when using {@link com.ibm.juno.server.RestServletDefault}:
		</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		properties={
			<jc>// Provide a default title on HTML pages.</jc>
			<ja>@Property</ja>(name=<jsf>HTMLDOC_title</jsf>, value=<js>"$R{servletLabel}"</js>),
			<jc>// Provide a default description on HTML pages.</jc>
			<ja>@Property</ja>(name=<jsf>HTMLDOC_description</jsf>, value=<js>"$R{servletDescription}"</js>)
		}
	)
	<jk>public abstract class</jk> RestServletDefault <jk>extends</jk> RestServlet {
	 	</p>
	 	<p>
	 		The label and description annotations support string variables.
	 		So in theory, you could also provide localized messages using <js>"$L"</js> variables pointing to your own resource bundle properties:
	 	</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		path=<js>"/example"</js>,
		messages=<js>"nls/Messages"</js>
		label=<js>"$L{my.resource.label}"</js>,
		description=<js>"$L{my.resource.description}"</js>
	)
	<jk>public class</jk> ExampleResource <jk>extends</jk> RestServletDefault {
		</p>
		<p>
			Another option is to override the {@link com.ibm.juno.server.RestServlet#getLabel(RestRequest)} 
				and {@link com.ibm.juno.server.RestServlet#getDescription(RestRequest)} methods.
		</p>	 	
	 	<h6 class='topic'>Method Description, Input, and Responses</h6>
	 	<p>
	 		The <l>methods</l> field in the OPTIONS page is mostly populated through reflection.
	 		However, the description, input, and responses field can be specified through either 
	 			annotations or resource properties. 
	 	</p>
	 	<p>
	 		For example, the <l>AddressBookResource</l> has a <l>getPerson()</l> method
	 			that gets rendered in the OPTIONS page like so...
	 	</p>
		<img class='bordered' src='doc-files/Options2.png'>
		<p>
			This method is described through the {@link com.ibm.juno.server.annotation.RestMethod#description() @RestMethod.description()}, 
				{@link com.ibm.juno.server.annotation.RestMethod#input() @RestMethod.input()},
				and {@link com.ibm.juno.server.annotation.RestMethod#responses() @RestMethod.responses()} annotations.
		</p>
		<p class='bcode'>
	<ja>@RestMethod</ja>(
		name=<js>"GET"</js>, 
		path=<js>"/people/{id}/*"</js>, 
		converters={Traversable.<jk>class</jk>,Queryable.<jk>class</jk>,Introspectable.<jk>class</jk>}, 
		description=<js>"Get a person by id in the address book"</js>,
		input={
			<ja>@Var</ja>(category=VarCategory.<jsf>ATTR</jsf>, name=<js>"id"</js>, description=<js>"Person UUID"</js>)
		},
		responses={
			<ja>@Response</ja>(
				value=200,
				output={
					<ja>@Var</ja>(category=VarCategory.<jsf>CONTENT</jsf>, description=<js>"Person bean"</js>)
				}
			),
			<ja>@Response</ja>(value=404, description=<js>"Person with specified id not found"</js>)
		}
	)
	<jk>public</jk> Person getPerson(<ja>@Attr</ja> <jk>int</jk> id) throws Exception {
		<jk>return</jk> findPerson(id);
	}
		</p> 	
		<p>
			These labels can also be localized by instead specifying them in the servlet properties file:		
		</p>		
		<p class='bcode'>
	<ja>@RestMethod</ja>(
		name=<js>"GET"</js>, 
		path=<js>"/people/{id}/*"</js>, 
		converters={Traversable.<jk>class</jk>,Queryable.<jk>class</jk>,Introspectable.<jk>class</jk>}
		<jc>// Don't specify annotations for labels...they'll be detected in resource bundle.</jc> 
	)
	<jk>public</jk> Person getPerson(<ja>@Attr</ja> <jk>int</jk> id) throws Exception {
		<jk>return</jk> findPerson(id);
	}
		</p> 	
		<p class='bcode'>
	<cc>#--------------------------------------------------------------------------------
	# Contents of AddressBookResource.properties
	#--------------------------------------------------------------------------------</cc>
	<ck>getPerson</ck> = <cv>Get a person by id in the address book</cv>
	<ck>getPerson.req.attr.id</ck> = <cv>Person UUID</cv>
	<ck>getPerson.res.200</ck> = <cv>Person found</cv>
	<ck>getPerson.res.404</ck> = <cv>Person with specified id not found</cv>
		</p>		
		<p>
			The following table shows the predefined resource bundle message property names:
		</p>
		<table class='styled'>
			<tr>
				<th>Property</th>
				<th>Description</th>
				<th>Equivalent Annotation</th>
				<th>Equivalent Method</th>
			</tr>
			<tr>
				<td><ck>label</ck></td>
				<td>Servlet label</td>
				<td>{@link com.ibm.juno.server.annotation.RestResource#label() @RestResource.label()}</td>
				<td>{@link com.ibm.juno.server.RestServlet#getLabel(RestRequest)}</td>
			</tr>
			<tr>
				<td><ck>description</ck></td>
				<td>Servlet description</td>
				<td>{@link com.ibm.juno.server.annotation.RestResource#description() @RestResource.description()}</td>
				<td>{@link com.ibm.juno.server.RestServlet#getDescription(RestRequest)}</td>
			</tr>
			<tr>
				<td><ck>[javaMethodName]</ck></td>
				<td>Java method description</td>
				<td>{@link com.ibm.juno.server.annotation.RestMethod#description() @RestMethod.description()}</td>
				<td>{@link com.ibm.juno.server.RestServlet#getMethodDescriptions(RestRequest)}</td>
			</tr>
			<tr>
				<td><ck>[javaMethodName].req.content</ck></td>
				<td>
					A description of the HTTP request content.
				</td>
				<td>{@link com.ibm.juno.server.annotation.RestMethod#input() @RestMethod.input()}</td>
				<td>{@link com.ibm.juno.server.RestServlet#getMethodDescriptions(RestRequest)}</td>
			</tr>
			<tr>
				<td><ck>[javaMethodName].req.[category].[name]</ck></td>
				<td>
					A request input variable.
					<br>Categories: <l>ATTR, PARAM, HEADER</l>
				</td>
				<td>{@link com.ibm.juno.server.annotation.RestMethod#input() @RestMethod.input()}</td>
				<td>{@link com.ibm.juno.server.RestServlet#getMethodDescriptions(RestRequest)}</td>
			</tr>
			<tr>
				<td><ck>[javaMethodName].res.[code]</ck></td>
				<td>
					A possible HTTP response code and description.
				</td>
				<td>{@link com.ibm.juno.server.annotation.RestMethod#responses() @RestMethod.responses()}</td>
				<td>{@link com.ibm.juno.server.RestServlet#getMethodDescriptions(RestRequest)}</td>
			</tr>
			<tr>
				<td><ck>[javaMethodName].res.[code].content</ck></td>
				<td>
					A description of response content for the specified HTTP response.
				</td>
				<td>{@link com.ibm.juno.server.annotation.RestMethod#responses() @RestMethod.responses()}</td>
				<td>{@link com.ibm.juno.server.RestServlet#getMethodDescriptions(RestRequest)}</td>
			</tr>
			<tr>
				<td><ck>[javaMethodName].res.[code].[category].[name]</ck></td>
				<td>
					A response output variable.
					<br>Categories: <l>ATTR, PARAM, HEADER</l>
				</td>
				<td>{@link com.ibm.juno.server.annotation.RestMethod#responses() @RestMethod.responses()}</td>
				<td>{@link com.ibm.juno.server.RestServlet#getMethodDescriptions(RestRequest)}</td>
			</tr>
		</table>
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#description() @RestMethod.description()}
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#input() @RestMethod.input()}
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#responses() @RestMethod.responses()}
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#rc() @RestMethod.rc()}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getServletLabel()}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getServletDescription()}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getMethodDescription()}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getMethodDescriptions()}
		</ul>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.Serializers"></a>
	<h3 class='topic' onclick='toggle(this)'>4.5 - Serializers</h3>
	<div class='topic'>
		<p>
			REST servlets use the {@link com.ibm.juno.core.serializer.Serializer} API for defining serializers for serializing response POJOs.
		</p>
		<p>
			The servlet will pick which serializer to use by matching the request <l>Accept</l> header with the
				media types defined through the {@link com.ibm.juno.core.serializer.Serializer#getMediaTypes()} method 
				(which itself usually comes from the {@link com.ibm.juno.core.annotation.Produces @Produces} annotation).
		</p>
		<p>
			Serializers can be associated with REST servlets in the following ways:
		</p>
		<ul class='javahierarchy'>
			<li class='n'>{@link com.ibm.juno.server.annotation.RestResource#serializers() @RestResource.serializers()} - Annotation on servlet class.
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#serializers() @RestMethod.serializers()} - Annotation on individual servlet methods.
			<li class='m'>{@link com.ibm.juno.server.RestServlet#createSerializers()} - Override method to set the serializers programmatically.
		</ul>
		<p>
			The following are equivalent ways of defining serializers used by a servlet...
		</p> 		
		<p class='bcode'>
	<jc>// Example #1 - Serializers defined on servlet through annotation</jc>
	<ja>@RestResource</ja>(
		serializers={JsonSerializer.<jk>class</jk>, XmlSerializer.<jk>class</jk>}
	)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		...
	}

 	<jc>// Example #2 - Serializers defined on method through annotation</jc>
 	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>
 		serializers={JsonSerializer.<jk>class</jk>, XmlSerializer.<jk>class</jk>}
 	)
	<jk>public</jk> Object doGet() {
 		...
	}

	<jc>// Example #3 - Serializers defined on servlet by overriding the createSerializers() method</jc>
	<ja>@Override</ja>
	<jk>public</jk> SerializerGroup createSerializers() {

 		SerializerGroup g = <jk>new</jk> SerializerGroup()
 			.append(JsonSerializer.<jk>class</jk>, XmlSerializer.<jk>class</jk>);

		<jk>return</jk> g;
	}
		</p>
		<p class='info'>
			When debugging the output from REST servlets, it's almost always easier to bypass the REST servlet and try to serialize
				the POJOs using the serializers directly using the {@link com.ibm.juno.core.serializer.WriterSerializer#toString(Object)} method.
		</p>
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#serializersInherit() @RestMethod.serializersInherit()}
				<br>Controls how serializers are inherited from the servlet class.
		</ul>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.Parsers"></a>
	<h3 class='topic' onclick='toggle(this)'>4.6 - Parsers</h3>
	<div class='topic'>
		<p>
			REST servlets use the {@link com.ibm.juno.core.parser.Parser} API for defining parsers for parsing request body content and converting them into POJOs.
		</p>
		<p>
			The servlet will pick which parser to use by matching the request <l>Content-Type</l> header with the
				media types defined through the {@link com.ibm.juno.core.parser.Parser#getMediaTypes()} method (which itself
				usually comes from the {@link com.ibm.juno.core.annotation.Consumes @Consumes} annotation).
		</p>
		<p>
			Parsers can be associated with REST servlets in the following ways:
		</p>
		<ul class='javahierarchy'>
			<li class='n'>{@link com.ibm.juno.server.annotation.RestResource#parsers() @RestResource.parsers()} - Annotation on servlet class.
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#parsers() @RestMethod.parsers()} - Annotation on individual servlet methods.
			<li class='m'>{@link com.ibm.juno.server.RestServlet#createParsers()} - Override method to set the parsers programmatically.
		</ul>
		<p>
			The following are equivalent ways of defining parsers used by a servlet...
		</p>
		<p class='bcode'>
		<jc>// Example #1 - Parsers defined on servlet through annotation</jc>
		<ja>@RestResource</ja>(
			parsers={JsonParser.<jk>class</jk>, XmlParser.<jk>class</jk>}
		)
		<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
			...
		}
	
	 	<jc>// Example #2 - Parsers defined on method through annotation</jc>
	 	<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/*"</js>
			parsers={JsonParser.<jk>class</jk>, XmlParser.<jk>class</jk>}
		)
		<jk>public void</jk> doPut(<ja>@Content</ja> Foo input) {
			...
		}
	
		<jc>// Example #3 - Parsers defined on servlet by overriding the getParserGroup method</jc>
		<ja>@Override</ja>
		<jk>public</jk> ParserGroup getParserGroup() {
	
	 		ParserGroup g = <jk>new</jk> ParserGroup()
				.append(JsonParser.<jk>class</jk>, XmlParser.<jk>class</jk>);
	
	 		<jk>return</jk> g;
	 	}
		</p>
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#parsersInherit() @RestMethod.parsersInherit()} 
				<br>Controls how parsers are inherited from the servlet class.
		</ul>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.Properties"></a>
	<h3 class='topic' onclick='toggle(this)'>4.7 - Properties</h3>
	<div class='topic'>
		<p>
			The Juno serializers and parsers are highly-configurable through properties.
			(See <a class='doclink' href='../../../../overview-summary.html#Core.ConfigurableProperties'>Configurable Properties</a>)
		</p>
		<p>
			There are several ways of defining properties in the REST API.
			The most common way is going to be through the {@link com.ibm.juno.server.annotation.RestResource#properties() @RestResource.properties()}
			and {@link com.ibm.juno.server.annotation.RestMethod#properties() @RestMethod.properties()} annotations.
		</p>
		<p>
			The {@link com.ibm.juno.server.annotation.RestResource#properties() @RestResource.properties()} annotation 
				can be used as a convenient way to set various serializer and parser
				properties to all serializers and parsers registered with the servlet.
		</p>
		<p class='bcode'>
	<jk>import static</jk> com.ibm.juno.core.SerializerProperties.*;
	<jk>import static</jk> com.ibm.juno.core.xml.XmlSerializerProperties.*;
	<jk>import static</jk> com.ibm.juno.server.serializers.HtmlSerializerProperties.*;

	<jc>// Servlet with properties applied</jc>
	<ja>@RestResource</ja>(
		properties={
			<jc>// Nulls should not be serialized</jc>
			<ja>@Property</ja>(name=<jsf>TRIM_NULLS</jsf>, value=<js>"true"</js>),

			<jc>// Empty lists should not be serialized</jc>
			<ja>@Property</ja>(name=<jsf>SERIALIZER_trimEmptyLists</jsf>, value=<js>"true"</js>),

			<jc>// Specify the default namespaces for the XML serializer</jc>
			<ja>@Property</ja>(name=<jsf>XML_defaultNamespaceUriS</jsf>,
				value=<js>"{jp06:'http://jazz.net/xmlns/prod/jazz/process/0.6/',jp:'http://jazz.net/xmlns/prod/jazz/process/1.0/'}"</js>),

			<jc>// Specify a default title for the HtmlSerializer serializer</jc>
			<ja>@Property</ja>(name=<jsf>HTMLDOC_title</jsf>, value=<js>"My resource"</js>)
		}
	)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		...
	}
		</p>
		<p>
			The {@link com.ibm.juno.server.annotation.RestMethod#properties() @RestMethod.properties()} annotation 
				can be used to define method-level properties that can alter the behavior of serializers and parsers at the method level only.
		</p>
		<p class='bcode'>
	<jc>// GET method with method-level properties</jc>
	<ja>@RestMethod</ja>(
		name=<js>"GET"</js>, path=<js>"/*"</js>,
		properties={
			<jc>// Nulls should not be serialized</jc>
			<ja>@Property</ja>(name=<jsf>TRIM_NULLS</jsf>, value=<js>"true"</js>),

			<jc>// Empty lists should not be serialized</jc>
			<ja>@Property</ja>(name=<jsf>SERIALIZER_trimEmptyLists</jsf>, value=<js>"true"</js>),

			<jc>// Specify the default namespaces for the XML serializer</jc>
			<ja>@Property</ja>(name=<jsf>XML_defaultNamespaceUriS</jsf>,
				value=<js>"{jp06:'http://jazz.net/xmlns/prod/jazz/process/0.6/',jp:'http://jazz.net/xmlns/prod/jazz/process/1.0/'}"</js>),

			<jc>// Specify a default title for the HtmlSerializer serializer</jc>
			<ja>@Property</ja>(name=<jsf>HTMLDOC_title</jsf>, value=<js>"My resource"</js>)
		}
	<jk>public</jk> Object doGet() {
		...
	}
		</p>
		<p>
			In particular, the {@link com.ibm.juno.server.RestServletProperties} class has a variety of properties
			for controlling the behavior of the {@link com.ibm.juno.server.RestServlet} class itself.
		</p>
		<p>
			There are also ways to provide properties programmatically.
		</p>
		<ul class='spaced-list'>
			<li>By overriding the {@link com.ibm.juno.server.RestServlet#createProperties()} method.
			<li>By overriding the {@link com.ibm.juno.server.RestServlet#createSerializers()} and 
				{@link com.ibm.juno.server.RestServlet#createParsers()} methods and setting properties on the 
				serializers and parsers directly.
			
		</ul>
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='c'>{@link com.ibm.juno.server.RestServletProperties}
				<br>Properties associated with the {@link com.ibm.juno.server.RestServlet} class.
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#serializersInherit @RestMethod.serializersInherit()} 
				<br>Controls how serializers inherit properties from the servlet class.
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#parsersInherit @RestMethod.parsersInheritInherit()} 
				<br>Controls how parsers inherit properties from the servlet class.
		</ul>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.Filters"></a>
	<h3 class='topic' onclick='toggle(this)'>4.8 - Filters</h3>
	<div class='topic'>
		<p>
			The Juno serializers and parsers can be configured on how to handle POJOs through the use of Filters.
			(See <a class='doclink' href='../../../../overview-summary.html#Core.Filters'>Filters</a>)
		</p>
		<p>
			The {@link com.ibm.juno.server.annotation.RestResource#filters() @RestResource.filters()} annotation 
			can be used as a convenient way to add POJO filters to the serializers and parsers
			registered with the servlet.
		</p>
		<p class='bcode'>
	<jc>// Servlet with filters applied</jc>
	<ja>@RestResource</ja>(
		filters={
			<jc>// Calendars should be serialized/parsed as ISO8601 date-time strings</jc>
			CalendarFilter.<jsf>DEFAULT_ISO8601DT</jsf>.<jk>class</jk>,

			<jc>// Byte arrays should be serialized/parsed as BASE64-encoded strings</jc>
			ByteArrayBase64Filter.<jk>class</jk>,

			<jc>// Subclasses of MyInterface will be treated as MyInterface objects.</jc>
			<jc>// Bean properties not defined on that interface will be ignored.</jc>
			MyInterface.<jk>class</jk>
		}
	)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		...
	}
		</p>
		<p>
			{@link com.ibm.juno.server.annotation.RestMethod#filters() @RestMethod.filters()}
				is the equivalent annotation for individual Java methods.
		</p>
		<p>
			Filters can also be defined programmatically through the following:
		</p>
		<ul class='spaced-list'>
			<li>By overriding the {@link com.ibm.juno.server.RestServlet#createFilters()} method.
			<li>By overriding the {@link com.ibm.juno.server.RestServlet#createSerializers()} and 
				{@link com.ibm.juno.server.RestServlet#createParsers()} methods and setting filters on the 
				serializers and parsers directly.
			
		</ul>
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#serializersInherit @RestMethod.serializersInherit()} 
				<br>Controls how serializers inherit filters from the servlet class.
			<li class='n'>{@link com.ibm.juno.server.annotation.RestMethod#parsersInherit @RestMethod.parsersInherit()} 
				<br>Controls how parsers inherit filters from the servlet class.
		</ul>
	</div>	
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.Guards"></a>
	<h3 class='topic' onclick='toggle(this)'>4.9 - Guards</h3>
	<div class='topic'>
		<p>
			Guards are classes that control access to REST servlets and methods.
		</p>
		<p>
			The {@link com.ibm.juno.server.annotation.RestResource#guards @RestResource.guards()} annotation 
				can be used to associate one or more class-level {@link com.ibm.juno.server.RestGuard RestGuards} with a servlet.
		</p>
		<p class='bcode'>
	<jc>// Servlet with class-level guard applied</jc>
	<ja>@RestResource</ja>(guards=BillyGuard.<jk>class</jk>)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {

 		<jc>// Delete method that only Billy is allowed to call.</jc>
		<jk>public</jk> doDelete(RestRequest req, RestResponse res) <jk>throws</jk> Exception {...}
 	}

	<jc>// Define a guard that only lets Billy make a request</jc>
	<jk>public</jk> BillyGuard <jk>extends</jk> RestGuard {

	<ja>@Override</ja>
		<jk>public boolean</jk> isRequestAllowed(RestRequest req) {
			return req.getUserPrincipal().getName().equals(<js>"Billy"</js>);
		}
	}
		</p>
		<p>
			A common use for guards is to only allow admin access to certain Java methods...
		</p>
		<p class='bcode'>
	<jc>// DELETE method</jc>
	<ja>@RestMethod</ja>(name=<js>"DELETE"</js>, guards={AdminGuard.<jk>class</jk>})
	<jk>public void</jk> doDelete(RestRequest req, RestResponse res) <jk>throws</jk> Exception {
		...
		</p>
		<p class='bcode'>
	<jk>public class</jk> AdminGuard <jk>extends</jk> RestGuard {
		<ja>@Override</ja>
		<jk>public boolean</jk> isRequestAllowed(RestRequest req) {
			<jk>return</jk> req.getUserPrincipal().isUserInRole(<js>"ADMIN"</js>);
		}
	}
		</p>
		<p>
			A guard failure results in an <l>HTTP 401 Unauthorized</l> response.
			However, this can be configured by overriding the {@link com.ibm.juno.server.RestGuard#guard(RestRequest,RestResponse)} 
				and processing the response yourself.
		</p>
		<p>
			When guards are associated at the class-level, it's equivalent to associating guards on all Java methods on the servlet.
		</p>
		<p>
			Class-level guards can also be created programmatically by overriding the {@link com.ibm.juno.server.RestServlet#createGuards()} method.
		</p>
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='a'>{@link com.ibm.juno.server.RestGuard} 
		</ul>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.Converters"></a>
	<h3 class='topic' onclick='toggle(this)'>4.10 - Converters</h3>
	<div class='topic'>
		<p>
			Converters can be thought of as a "post-processor" for POJOs before they get passed to the serializers.
		</p>
		<p>
			The {@link com.ibm.juno.server.annotation.RestResource#converters @RestResource.converters()} annotation 
				can be used as a convenient way to add {@link com.ibm.juno.server.RestConverter RestConverters} to
				all Java REST methods on a servlet.
		</p>
		<p class='bcode'>
	<jc>// Associate the Traversable converter to all Java REST methods in this servlet</jc>
	<ja>@RestResource</ja>(converters=Traversable.<jk>class</jk>)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		...
	}
		</p>
		<p>
			The {@link com.ibm.juno.server.annotation.RestMethod#converters() @RestMethod.converters()} annotation 
				can be used to associate converters on individual methods.
		</p>
		<p class='bcode'>
	<jc>// GET person request handler.</jc>
	<jc>// Traversable conversion enabled to allow nodes in returned POJO tree to be addressed.</jc>
	<jc>// Queryable conversion enabled to allow returned POJO to be searched/viewed/sorted.</jc>
	<ja>@RestMethod</ja>(
			name=<js>"GET"</js>, path=<js>"/people/{id}/*"</js>,
			converters={Traversable.<jk>class</jk>,Queryable.<jk>class</jk>}
	)
	<jk>public</jk> Person getPerson(<ja>@Attr</ja> <jk>int</jk> id) {
		<jk>return</jk> findPerson(id);
	}
		</p>	
		<p>
			The following converter is used to provide support for addressing child nodes in a POJO tree with
				URL path remainders.  
			<br>In this code, the 3rd parameter is the object that was returned by the Java method (or set through <l>request.setObject(o);</l>).
			<br>The converter uses the {@link com.ibm.juno.core.utils.PojoRest} wrapper class to address nodes in the tree.
		</p>
		<p class='bcode'>
	<jd>/**
	 * Converter for enablement of PojoRest support on response objects returned by a @RestMethod method.
	 * When enabled, objects in a POJO tree returned by the REST method can be addressed through additional URL path information.
	 */</jd>
	<jk>public class</jk> Traversable <jk>implements</jk> RestConverter {
	
		<ja>@Override</ja>
		<jk>public</jk> Object convert(RestServlet resource, RestRequest req, Object o) {
			if (o == <jk>null</jk>)
				<jk>return null</jk>;
	
			BeanContext beanContext = resource.getBeanContext();
			
			<jk>if</jk> (req.getRemainder() != <jk>null</jk>) {
				PojoRest p = <jk>new</jk> PojoRest(o, beanContext);
				<jk>try</jk> {
					o = p.get(req.getRemainder());
				} <jk>catch</jk> (PojoRestException e) {
					<jk>throw new</jk> RestException(e.getStatus(), e.getMessage(), e);
				}
			}
			
			<jk>return</jk> o;
		}
	}
		</p>	
		<p>
			Juno defines the following converters out-of-the-box:
		</p>
		<ul class='javahierarchy'>
			<li class='i'>{@link com.ibm.juno.server.RestConverter}
			<ul>
				<li class='c'>{@link com.ibm.juno.server.converters.Queryable}
					<br>Provides query parameters that can be used to filter the response (i.e. search/view/sort the POJO response before being serialized).
				<li class='c'>{@link com.ibm.juno.server.converters.Traversable}
					<br>Allows nodes in the POJO response tree to be individually accessed through additional path info on the request.
				<li class='c'>{@link com.ibm.juno.server.converters.Introspectable}
					<br>Allows method calls to be made on the response POJO, and for the result of that method call to be serialized as the response.
			</ul>
		</ul>
		<p>
			Class-level converters can be created programmatically by overriding the {@link com.ibm.juno.server.RestServlet#createConverters()} method.
		</p>
		<p>
			Note that from the example above, you can specify more than one converter.
			When multiple converters are used, they're executed in the order they're specified in the annotation
			(e.g. first the results will be traversed, then the resulting node will be searched/sorted).
			
		</p>
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='i'>{@link com.ibm.juno.server.RestConverter} 
		</ul>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.Children"></a>
	<h3 class='topic' onclick='toggle(this)'>4.11 - Child Resources</h3>
	<div class='topic'>		
		<p>
			Child Resources are REST servlets that are linked to parent servlets through the 
				{@link com.ibm.juno.server.annotation.RestResource#children() @RestResource.children()} annnotation.
		</p>
		<p class='bcode'>
	<jd>/** Parent Resource */</jd>
	<ja>@RestResource</ja>(
		path=<js>"/parent"</js>,
		children={Foo.<jk>class</jk>}
	)
	<jk>public</jk> MyResource <jk>extends</jk> RestServlet {
		...
		</p>
		<p class='bcode'>
	<jd>/** Child Resource */</jd>
 	<ja>@RestResource</ja>(
		path=<js>"/foo"</js>  // Path relative to parent resource.
	)
	<jk>public</jk> FooResource <jk>extends</jk> RestServlet {
		...
		</p>
		<p>
			A HUGE advantage of using child resources is that they do not need to be declared in the JEE <l>web.xml</l> file.
			Initialization of and access to the child resources occurs through the parent resource.
			Children can be nested arbitrary deep to create complex REST interfaces with a single top-level REST servlet.
		</p>
		<p>
			The path of the child resource gets appended to the path of the parent resource. 
			So in the example above, the child resource is accessed through the URL <l>/parent/foo</l>.
		</p>
		<p>
			The {@link com.ibm.juno.server.RestServletGroupDefault} class provides a default "router" page for 
				child resources when a parent resource is nothing more than a grouping of child resources.
		</p>		
		<p>
			The <l>RootResources</l> class in the Samples project is an example of a router page:
		</p>
		<p class='bcode'>		
	<jd>/**
	 * Sample REST resource showing how to implement a "router" resource page.
	 */</jd>
	<ja>@RestResource</ja>(
		path=<js>"/"</js>,
		messages=<js>"nls/RootResources"</js>,
		properties={
			<ja>@Property</ja>(name=HTMLDOC_links, value=<js>"{options:'$R{servletURI}?method=OPTIONS',source:'$R{servletURI}/source?classes=(com.ibm.juno.server.samples.RootResources)'}"</js>)
		},
		children={
			HelloWorldResource.<jk>class</jk>,
			MethodExampleResource.<jk>class</jk>,
			RequestEchoResource.<jk>class</jk>,
			TempDirResource.<jk>class</jk>,
			AddressBookResource.<jk>class</jk>,
			SampleRemoteableServlet.<jk>class</jk>,
			PhotosResource.<jk>class</jk>,
			AtomFeedResource.<jk>class</jk>,
			JsonSchemaResource.<jk>class</jk>,
			SqlQueryResource.<jk>class</jk>,
			TumblrParserResource.<jk>class</jk>,
			CodeFormatterResource.<jk>class</jk>,
			UrlEncodedFormResource.<jk>class</jk>,
			SourceResource.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			LogsResource.<jk>class</jk>,
			DockerRegistryResource.<jk>class</jk>,
			ShutdownResource.<jk>class</jk>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> ResourceGroup {
		<jk>private static final long</jk> <jsf>serialVersionUID</jsf> = 1L;
	}
		</p>
		<p>
			When you bring up this resource in a browser, you see the following:
		</p>
		<img class='bordered' src="doc-files/Samples_RootResources.png"/>
		<p> 
			The <l>RestServletGroupDefault</l> class is nothing more than a subclass of 
				{@link com.ibm.juno.server.RestServletDefault} with a <l>getChildren()</l>
				method mapped to the servlet root path.
			The method returns a POJO with is just a linked-list of beans with name/description 
				properties.
		</p>	
		<p class='bcode'>
	<jk>public class</jk> RestServletGroupDefault <jk>extends</jk> RestServletDefault {
	
		<jd>/**
		 * [GET /] - Get child resources.
		 *
		 * <ja>@param</ja> req The HTTP request.
		 * <ja>@return</ja> The bean containing links to the child resources.
		 */</jd>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>, description=<js>"Child resources"</js>)
		<jk>public</jk> ChildResourceDescriptions getChildren(RestRequest req) {
			<jk>return new</jk> ChildResourceDescriptions(<jk>this</jk>, req);
		}
	}		
		</p>
		<p>
			Children can also be defined programmatically by overriding any of the following methods:
		</p>
		<ul class='javahierarchy'>
			<li class='a'>{@link com.ibm.juno.server.RestServlet}
			<ul>
				<li class='m'>{@link com.ibm.juno.server.RestServlet#getChildClasses() getChildClasses()}
					<br>Programmatic equivalent to {@link com.ibm.juno.server.annotation.RestResource#children() @RestResource.children()} annotation.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#createChildren() createChildren()}
					<br>Creates instances of classes returned by {@link com.ibm.juno.server.RestServlet#getChildClasses() getChildClasses()}.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#createChildrenMap() createChildrenMap()}
					<br>Uses {@link com.ibm.juno.server.RestServlet#createChildren() createChildren()} and 
						{@link com.ibm.juno.server.annotation.RestResource#path() @RestResource.path()} to create a map of child URLs to child servlets.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#addChildResource(String,RestServlet) addChildResource(String,RestServlet)}
					<br>Can be used to programmatically add a REST servlet.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#resolveChild(Class) resolveChild(Class)}
					<br>An interceptor method that can be used to provide custom resolution of a child resource.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#replaceChild(RestServlet) replaceChild(RestServlet)}
					<br>Allows a child to be replaced at runtime without affecting the parent.
			</ul> 
		</ul>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.Labels"></a>
	<h3 class='topic' onclick='toggle(this)'>4.12 - Localized Messages</h3>
		<p>
			The {@link com.ibm.juno.server.annotation.RestResource#messages @RestResource.messages()} annotation can be used to associate a resource bundle with a servlet class.
		</p>
		<p class='bcode'>
	<jc>// Servlet with associated resource bundle</jc>
	<ja>@RestResource</ja>(messages=<js>"nls/MyMessages"</js>)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {

		<jc>// Returns the localized greeting from the "greeting" key in MyMessages.properties</jc>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>)
		<jk>public</jk> String printLocalizedGreeting(RestRequest req) {
			<jk>return</jk> req.getMessage(<js>"greeting"</js>);
		}
		</p>
		<p>	
			The resource bundle can also be passed into the method by using the {@link com.ibm.juno.server.annotation.Messages @Messages} annotation:
		</p>
		<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"GET"</js>)
	<jk>public</jk> String printLocalizedGreeting(<ja>@Messages</ja> ResourceBundle messages) {
		<jk>return</jk> messages.getString(<js>"greeting"</js>);
	}
		</p>
		<p>
			If a resource bundle is shared by multiple servlets, the label and description can be prefixed by the class name:
		</p>
		<p class='bcode'>
	<cc>#--------------------------------------------------------------------------------
	# Contents of MyMessages.properties
	#--------------------------------------------------------------------------------</cc>
	<ck>greeting</ck> = Hello!
		</p>	 	
		<p class='bcode'>
	<cc>#--------------------------------------------------------------------------------
	# Contents of shared MyMessages.properties
	#--------------------------------------------------------------------------------</cc>
	<ck>MyRestServlet.greeting</ck> = Hello!
		</p>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.Encoders"></a>
	<h3 class='topic' onclick='toggle(this)'>4.13- Encoders</h3>
	<div class='topic'>
		<p>
			The {@link com.ibm.juno.server.annotation.RestResource#encoders @RestResource.encoders()} annotation can be used to associate character encoders with a servlet class.
			Encoders can be used to enable various kinds of compression (e.g. <l>"gzip"</l>) on requests and responses based on the request <l>Accept-Encoding</l>
				and <l>Content-Encoding</l> headers.
		</p>
		<h6 class='figure'>Example:</h6>
		<p class='bcode'>
	<jc>// Servlet with automated support for GZIP compression</jc>
	<ja>@RestResource</ja>(encoders={GzipEncoder.<jk>class</jk>})
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		...
	}
		</p>
		<p>
			Juno defines the following encoders out-of-the-box:
		</p>
		<ul class='javahierarchy'>
			<li class='a'>{@link com.ibm.juno.core.encoders.Encoder}
			<ul>
				<li class='c'>{@link com.ibm.juno.core.encoders.GzipEncoder}
				<li class='c'>{@link com.ibm.juno.core.encoders.IdentityEncoder}
			</ul>
		</ul>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.StringVars"></a>
	<h3 class='topic' onclick='toggle(this)'>4.14- String Variables</h3>
	<div class='topic'>
		<p>	
			In the previous examples, there were several cases where embedded variables were contained within
				annotation values:
		</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		label=<js>"$L{my.label}"</js>
 		properties={
 			<ja>@Property</ja>(name=<jsf>HTMLDOC_links</jsf>, value=<js>"{options:'$R{servletURI}?method=OPTIONS'"</js>)
 		}
    )
		</p>
		<p>
			Variables are of the form <l>$X{key}</l>, where <l>X</l> can consist of zero or more ASCII characters.
		</p>
		<p>
			Features include:
		</p>
		<ul class='spaced-list'>
			<li>Variables can be nested arbitrarily deep (e.g. <l>"$X{$Y{foo}}"</l>).
			<li>Variables can contain arguments (e.g. <l>"$L{my.label,arg1,arg2}"</l>).
			<li>Variables are recursively resolved. 
				<br>i.e., if a variable results to a value with another variable in it, that
					variable will also be resolved.
		</ul>
		<p>	
			String variables are implemented through the {@link com.ibm.juno.core.utils.StringVarResolver} and 
				{@link com.ibm.juno.core.utils.StringVar} classes. 
		</p>
		<h6 class='figure'>Example:</h6>
		<p class='bcode'>
	<jc>// Create a variable resolver that resolves system properties (e.g. "$S{java.home}")</jc>
	StringVarResolver r = <jk>new</jk> StringVarResolver()
		.addVar(<js>"S"</js>, <jk>new</jk> StringVar() {
			<ja>@Override</ja>
			<jk>public</jk> String resolve(String varVal) {
				<jk>return</jk> System.<jsm>getProperty</jsm>(varVal);
			}
		});
 	System.<jsf>out</jsf>.println(r.resolve(<js>"java.home is set to $S{java.home}"</js>));
		</p>
		<p>
			The methods that define the string var resolver on a servlet are:
		</p>
		<ul class='javahierarchy'>
			<li class='a'>{@link com.ibm.juno.server.RestServlet}
			<ul>
				<li class='m'>{@link com.ibm.juno.server.RestServlet#getVarResolver()}
					<br>Returns the <l>StringVarResolver</l> associated with a servlet.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#createVarResolver()}
					<br>The method used to create the servlet <l>StringVarResolver</l>.
					<br>Subclasses can override this method to provide their own resolver.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#createRequestVarResolver(RestRequest)}
					<br>The method used to create a <l>StringVarResolver</l> for a single HTTP request.
					<br>Subclasses can override this method to provide their own resolver.
			</ul>
		</ul>
		<p>
			The default {@link com.ibm.juno.server.RestServlet#createVarResolver()} method provides 
				support the following string variable types:
		</p>
		<table class='styled'>
			<tr>
				<th>Variable</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><ck>$S{key}</ck><br><ck>$S{key,default}</ck></td>
				<td>System properties.</td>
			</tr>
			<tr>
				<td><ck>$E{key}</ck><br><ck>$E{key,default}</ck></td>
				<td>Environment variables.</td>
			</tr>
			<tr>
				<td><ck>$I{key}</ck><br><ck>$I{key,default}</ck></td>
				<td>Servlet initialization parameters.</td>
			</tr>
			<tr>
				<td><ck>$C{key}</ck><br><ck>$C{key,default}</ck></td>
				<td>Values from the config file returned by {@link com.ibm.juno.server.RestServlet#getConfig()}.</td>
			</tr>
		</table>
		<p>
			The default values are used when a property doesn't resolve to a value.
			<br>(e.g. <l>"$S{myBooleanProperty,true}"</l>).
		</p>
		<p>
			Like all other variables, keys and default values can themselves be arbitrarily nested.
			<br>(e.g. <l>"$S{$E{BOOLEAN_PROPERTY_NAME},$E{BOOLEAN_DEFAULT}}"</l>)
		</p>
		<p>	
			Subclasses can augment this list by adding their own variables.
		</p>
		<h6 class='figure'>Example:</h6>
		<p class='bcode'>
	<ja>@Override</ja> <jc>/* RestServlet */</jc>
	<jk>protected</jk> StringVarResolver createVarResolver() {

		<jc>// Augment the default variable resolver.</jc>
		StringVarResolver r = <jk>super</jk>.createVarResolver();

		<jc>// Wrap all strings inside [] brackets.
		// e.g. "$BRACKET{foobar}" -> "[foobar]"</jc>
		r.addVar(<js>"BRACKET"</js>, <jk>new</jk> StringVar() {
			<ja>@Override</ja>
			<jk>public</jk> String resolve(String varVal) {
				<jk>return</jk> <js>'['</js> + varVal + <js>']'</js>;
			}
		});

		<jk>return</jk> s;
	}
		</p>
		<p>
			The default {@link com.ibm.juno.server.RestServlet#createRequestVarResolver(RestRequest)} method provides 
				support for all the servlet-level variables, and augments it with the following request-specic
				variable types:
		</p>
		<table class='styled'>
			<tr>
				<th>Variable</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><ck>$L{key}</ck><br><ck>$L{key,args...}</ck></td>
				<td>Localized strings pulled from resource bundle.
					<br>Resolves to the value returned by {@link com.ibm.juno.server.RestRequest#getMessage(String, Object...)}.
					<br>Can include message arguments (e.g. <l>"$L{my.localized.string, foo, bar}"</l>)
				</td>
			</tr>
			<tr>
				<td><ck>$A{key}</ck><br><ck>$A{key,default}</ck></td>
				<td>Request attributes.
					<br>Resolves to the value returned by {@link com.ibm.juno.server.RestRequest#getAttribute(String)}.
					<br>Can include a default value (e.g. <l>"$A{myAttribute,myDefaultValue}"</l>)
				</td>
			</tr>
			<tr>
				<td><ck>$P{key}</ck><br><ck>$P{key,default}</ck></td>
				<td>Request parameters.
					<br>Resolves to the value returned by {@link com.ibm.juno.server.RestRequest#getParameter(String)}.
					<br>Can include a default value (e.g. <l>"$P{myAttribute,myDefaultValue}"</l>)
				</td>
			</tr>
			<tr>
				<td><ck>$R{key}</ck></td>
				<td>Request-specific variables.
					<br>Possible values:
					<ul>
						<li><ck>$R{contextPath}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getContextPath()}.
						<li><ck>$R{method}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getMethod()}.
						<li><ck>$R{methodDescription}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getMethodDescription()}.
						<li><ck>$R{pathInfo}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getPathInfo()}.
						<li><ck>$R{requestParentURI}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getRequestParentURI()}.
						<li><ck>$R{requestURI}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getRequestURI()}.
						<li><ck>$R{servletDescription}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getServletDescription()}.
						<li><ck>$R{servletLabel}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getServletLabel()}.
						<li><ck>$R{servletParentURI}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getServletParentURI()}.
						<li><ck>$R{servletPath}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getServletPath()}.
						<li><ck>$R{servletURI}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getServletURI()}.
						<li><ck>$R{trimmedRequestURI}</ck> - Value returned by {@link com.ibm.juno.server.RestRequest#getTrimmedRequestURI()}.
					</ul>
				</td>
			</tr>
			<tr>
				<td><ck>$UE{...}</ck></td>
				<td>URL-Encode the specified value.
					<br>Takes the contents inside the varible and replaces it with the value returned by calling {@link com.ibm.juno.server.RestUtils#encode(String)}.
				</td>
			</tr>
		</table>
		<p>
			In addition to being used in annotation values, string variables can also be embedded in resource files retrieved
				through the {@link com.ibm.juno.server.RestRequest#getReaderResource(String,boolean)} method.
			This can often be useful for embedding localized strings inside HTML form pages.  
		</p>
		<p>
			The <l>UrlEncodedFormResource</l> class in the Samples shows an example of using an HTML form page with
				localized variables.  When you bring it up in a browser, you see the following:
		</p>
		<img class='bordered' src='doc-files/UrlEncodedForm.png'>
		<p>
			This HTML page is a static file located in the <l>com.ibm.juno.server.samples</l> package.
		</p>	
		<h6 class='figure'>Contents of com/ibm/juno/server/samples/UrlEncodedForm.html</h6>
		<p class='bcode'>
	<xt>&lt;html&gt;</xt> 
		<xt>&lt;head&gt;</xt> 
			<xt>&lt;style</xt> <xa>type</xa>=<xs>'text/css'</xs><xt>&gt;</xt> 
				<xt>@import</xt> <xs>'$R{servletURI}/style.css'</xs>; 
			<xt>&lt;/style&gt;</xt> 
		<xt>&lt;/head&gt;</xt> 
		<xt>&lt;body&gt;</xt> 
			<xt>&lt;h3</xt> <xa>class</xa>=<xs>'title'</xs><xt>&gt;</xt>$R{servletLabel}<xt>&lt;/h3&gt;</xt> 
			<xt>&lt;h5</xt> <xa>class</xa>=<xs>"description"</xs><xt>&gt;</xt>$R{servletDescription}<xt>&lt;/h5&gt;</xt> 
			<xt>&lt;div</xt> <xa>class</xa>=<xs>'data'</xs><xt>&gt;</xt> 
				<xt>&lt;form</xt> <xa>id</xa>=<xs>'form'</xs> <xa>action</xa>=<xs>'$R{servletURI}'</xs> <xa>method</xa>=<xs>'POST'</xs><xt>&gt;</xt> 
					<xt>&lt;table&gt;</xt> 
						<xt>&lt;tr&gt;</xt> 
							<xt>&lt;th&gt;</xt>$L{aString}<xt>&lt;/th&gt;</xt> 
							<xt>&lt;td&gt;</xt><xt>&lt;input</xt> <xa>name</xa>=<xs>"aString"</xs> <xa>type</xa>=<xs>"text"</xs><xt>&gt;</xt><xt>&lt;/td&gt;</xt> 
						<xt>&lt;/tr&gt;</xt> 
						<xt>&lt;tr&gt;</xt> 
							<xt>&lt;th&gt;</xt>$L{aNumber}<xt>&lt;/th&gt;</xt> 
							<xt>&lt;td&gt;</xt><xt>&lt;input</xt> <xa>name</xa>=<xs>"aNumber"</xs> <xa>type</xa>=<xs>"number"</xs><xt>&gt;</xt><xt>&lt;/td&gt;</xt> 
						<xt>&lt;/tr&gt;</xt> 
						<xt>&lt;tr&gt;</xt> 
							<xt>&lt;th&gt;</xt>$L{aDate}<xt>&lt;/th&gt;</xt> 
							<xt>&lt;td&gt;</xt><xt>&lt;input</xt> <xa>name</xa>=<xs>"aDate"</xs> <xa>type</xa>=<xs>"datetime"</xs><xt>&gt;</xt> (ISO8601, e.g. "<xt>&lt;code&gt;</xt>2001-07-04T15:30:45Z<xt>&lt;/code&gt;</xt>")<xt>&lt;/td&gt;</xt> 
						<xt>&lt;/tr&gt;</xt> 
						<xt>&lt;tr&gt;</xt> 
							<xt>&lt;td</xt> <xa>colspan</xa>=<xs>'2'</xs> <xa>align</xa>=<xs>'right'</xs><xt>&gt;</xt><xt>&lt;button</xt> <xa>type</xa>=<xs>"submit"</xs><xt>&gt;</xt>$L{submit}<xt>&lt;/button&gt;</xt><xt>&lt;/td&gt;</xt> 
						<xt>&lt;/tr&gt;</xt> 
					<xt>&lt;/table&gt;</xt> 
				<xt>&lt;/form&gt;</xt> 
			<xt>&lt;/div&gt;</xt> 
		<xt>&lt;/body&gt;</xt> 
	<xt>&lt;/html&gt;</xt>		
		</p>
		<h6 class='figure'>Contents of UrlEncodedFormResource.java</h6>
		<p class='bcode'>
	<jd>/** 
	* Sample REST resource for loading URL-Encoded form posts into POJOs. 
	 */</jd>
	<ja>@RestResource</ja>(
		path=<js>"/urlEncodedForm"</js>, 
		messages=<js>"nls/UrlEncodedFormResource"</js>, 
		properties={
			<ja>@Property</ja>(name=HTMLDOC_title, value=<js>"URL-encoded Form Post Resource"</js>), 
			<ja>@Property</ja>(name=HTMLDOC_description, value=<js>"Shows how form posts are converted into beans."</js>), 
			<ja>@Property</ja>(name=HTMLDOC_links, value=<js>"{up:'$R{requestParentURI}',options:'?method=OPTIONS',source:'$R{servletParentURI}/source?classes=(com.ibm.juno.server.samples.UrlEncodedFormResource)'}"</js>) 
		} 
	) 
	<jk>public class</jk> UrlEncodedFormResource <jk>extends</jk> Resource { 
		<jk>private static final long</jk> <jsf>serialVersionUID</jsf> = 1L; 
		
		<jd>/** GET request handler */</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>) 
		<jk>public</jk> ReaderResource doGet(RestRequest req) <jk>throws</jk> IOException { 
			<jk>return</jk> req.getReaderResource(<js>"UrlEncodedForm.html"</js>, <jk>true</jk>); 
		} 
		
		<jd>/** POST request handler */</jd> 
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/"</js>) 
		<jk>public</jk> Object doPost(<ja>@Content</ja> FormInputBean input) <jk>throws</jk> Exception { 
			<jc>// Just mirror back the request</jc> 
			<jk>return</jk> input; 
		} 
		
		<jk>public static class</jk> FormInputBean { 
			<jk>public</jk> String <jf>aString</jf>; 
			<jk>public int</jk> <jf>aNumber</jf>; 
			<ja>@BeanProperty</ja>(filter=CalendarFilter.<jsf>ISO8601DT</jsf>.<jk>class</jk>) 
			<jk>public</jk> Calendar <jf>aDate</jf>; 
		} 
	}
		</p>
		<h6 class='figure'>Contents of UrlEncodedFormResource.properties</h6>
		<p class='bcode'>
	<cc>#--------------------------------------------------------------------------------
	# UrlEncodedFormResource labels
	#--------------------------------------------------------------------------------</cc>
	<ck>label</ck> = <cv>URL-Encoded Form Post Example</cv>
	<ck>description</ck> = <cv>Shows how URL-Encoded form input can be loaded into POJOs.  POJO is simply echoed back.</cv>
	<ck>aString</ck> = <cv>A String:</cv>
	<ck>aNumber</ck> = <cv>A Number:</cv>
	<ck>aDate</ck> = <cv>A Date:</cv>
	<ck>submit</ck> = <cv>submit</cv>
		</p>
		
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='c'>{@link com.ibm.juno.server.ReaderResource}
			<li class='m'>{@link com.ibm.juno.server.RestRequest#getReaderResource(String,boolean)}
			<li class='c'>{@link com.ibm.juno.core.utils.StringVarResolver}
		</ul>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.StaticFiles"></a>
	<h3 class='topic' onclick='toggle(this)'>4.15 - Static Files</h3>
	<div class='topic'>
		<p>
			The {@link com.ibm.juno.server.annotation.RestResource#staticFiles @RestResource.staticFiles()} annotation
				is used to define paths and locations of statically-served files such as images or HTML documents.
		</p>
		<p>
			The value is a JSON map of paths to packages/directories located on either the classpath or working directory.
		</p>
		<h6 class='figure'>Example:</h6>
		<p class='bcode'>
	<jk>package</jk> com.ibm.mypackage;

	<ja>@RestResource</ja>(
		path=<js>"/myresource"</js>,
		staticFiles=<js>"{htdocs:'docs'}"</js>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> RestServletDefault {
	}
		</p>
		<p>	
			Static files are found by calling {@link java.lang.Class#getResource(String)} up the class hierarchy.  
			If not found, then an attempt is made to find the class in the Java working directory.
		</p>
		<p>
			In the example above, given a GET request to <l>/myresource/htdocs/foobar.html</l>, the servlet will attempt to find the <l>foobar.html</l> file
				in the following ordered locations:
		</p>
		<ol>
			<li><l>com.ibm.mypackage.docs</l> package.
			<li><l>com.ibm.juno.server.docs</l> package (since <l>RestServletDefault</l> is in <l>com.ibm.juno.server</l>).
			<li><l>[working-dir]/docs</l> directory.
		</ol>
		<h6 class='topic'>Notes:</h6>
		<ul class='spaced-list'>
			<li>Mappings are cumulative from parent to child.  Child resources can override mappings made on parent resources.
			<li>The media type on the response is determined by the {@link com.ibm.juno.server.RestServlet#getMimetypesFileTypeMap()} method.
		</ul>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.Listeners"></a>
	<h3 class='topic' onclick='toggle(this)'>4.16 - Listener Methods</h3>	
	<div class='topic'>
		<p>
			Various convenience listener methods are provided on the {@link com.ibm.juno.server.RestServlet} class
				that subclasses can use to intercept requests:
		</p>
		<ul class='javahierarchy'>
			<li class='a'>{@link com.ibm.juno.server.RestServlet}
			<ul>
				<li class='m'>{@link com.ibm.juno.server.RestServlet#onPreCall(RestRequest) onPreCall(RestRequest)}
					<br>Callback method that gets invoked right before the REST Java method is invoked.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#onPostCall(RestRequest,RestResponse) onPostCall(RestRequest,RestResponse)}
					<br>Callback method that gets invoked right after the REST Java method is invoked, but before the serializer is invoked.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#onSuccess(RestRequest,RestResponse,long) onSuccess(RestRequest,RestResponse,long)}
					<br>Callback method for listening for successful completion of requests.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#onError(HttpServletRequest,HttpServletResponse,RestException) onError(HttpServletRequest,HttpServletResponse,RestException)}
					<br>Callback method for logging errors during HTTP requests.
			</ul>
		</ul>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.Stylesheet"></a>
	<h3 class='topic' onclick='toggle(this)'>4.17 - Stylesheet</h3>	
	<div class='topic'>
		<p>
			The {@link com.ibm.juno.server.annotation.RestResource#stylesheet @RestResource.stylesheet()} annotation
				is used to identify the stylesheet to use when rendering POJOs as HTML.
		</p>
		<p>
			The value is a path to a stylesheet located in either the classpath or working directory.
			The resulting stylesheet becomes available as a static file through the servlet via the URL <js>"[servletpath]/style.css"</js>.
		</p>		
		<p>
			The default set of styles located in the <l>com.ibm.juno.server.styles</l> package are:
		</p>
		<ul>
			<li><l>"styles/devops.css"</l> - Theme based on IBM DevOps look-and-feel.
			<li><l>"styles/juno.css"</l> - Theme based on Jazz look-and-feel.
		</ul>
		<p>
			The DevOps look-and-feel is the newer style:
		</p>
		<img class='bordered' src='doc-files/AddressBook.png'>
		<p>
			The Juno look-and-feel is an older style based on the Jazz Framework:
		</p>
		<img class='bordered' src='doc-files/AddressBook_junostyle.png'>
		<p>
			Stylesheets are first found in the classpath relative to the servlet class.
			If the stylesheet cannot be found on the classpath, an attempt to look in the working directory.
		</p>	
		<p>
			If the file cannot be located, the request to <l>"[servletpath]/style.css"</l> will return {@link javax.servlet.http.HttpServletResponse#SC_NOT_FOUND}.
		</p>
		<p>
			Custom stylesheets can be defined by specifying your own stylesheet annotation value:
		</p>
		<p class='bcode'>
	<jk>package</jk> com.ibm.mypackage;
	<ja>@RestResource</ja>(
		stylesheet=<js>"mystyles/mycss.css"</js>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> RestServletDefault {
	}
		</p>
		<p>
			In this example, the servlet will attempt to find the <l>mycss.css</l> file in the following ordered locations:
		</p>			
		<ol>
			<li><l>com.ibm.mypackage.mystyles</l> package.
			<li><l>com.ibm.juno.server.mystyles</l> package (since <l>RestServletDefault</l> is in <l>com.ibm.juno.server</l>).
			<li><l>[working-dir]/mystyles</l> directory.
		</ol>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.Headers"></a>
	<h3 class='topic' onclick='toggle(this)'>4.18 - Default Headers</h3>
	<div class='topic'>
		<p>
			The following annotations are provided for specifying default header values for requests and responses:
		</p>
		<ul class='javahierarchy'>
			<li class='n'>{@link com.ibm.juno.server.annotation.RestResource#defaultRequestHeaders() @RestResource.defaultRequestHeaders()} 
				<br>Defines default headers on request when the client doesn't specify them.
			<li class='n'>{@link com.ibm.juno.server.annotation.RestResource#defaultResponseHeaders() @RestResource.defaultResponseHeaders()}
				<br>Appends the specified headers if they weren't already set programmatically.	
		</ul>		
		<h6 class='figure'>Example:</h6>
		<p class='bcode'>
	<jc>// Servlet with default headers</jc>
	<ja>@RestResource</ja>(

		<jc>// Assume "text/json" Accept value when Accept not specified</jc>
		defaultRequestHeaders={<js>"Accept: text/json"</js>},

		<jc>// Add a version header attribute to all responses</jc>
		defaultResponseHeaders={<js>"X-Version: 1.0"</js>}
	)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		...
	}			
		</p>
		<p>
			Default headers can also be specified programmatically by overriding the following methods:
		</p>
		<ul class='javahierarchy'>
			<li class='a'>{@link com.ibm.juno.server.RestServlet}
			<ul>
				<li class='m'>{@link com.ibm.juno.server.RestServlet#createDefaultRequestHeaders() createDefaultRequestHeaders()}
				<li class='m'>{@link com.ibm.juno.server.RestServlet#createDefaultResponseHeaders() createDefaultResponseHeaders()}
			</ul>
		</ul>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.Errors"></a>
	<h3 class='topic' onclick='toggle(this)'>4.19 - Handling Errors / Logging</h3>
	<div class='topic'>
		<p>
			The following overridable methods are provided for handling errors on requests:
		</p>
		<ul class='javahierarchy'>
			<li class='a'>{@link com.ibm.juno.server.RestServlet}
			<ul>
				<li class='m'>{@link com.ibm.juno.server.RestServlet#onError(HttpServletRequest,HttpServletResponse,RestException) onError(HttpServletRequest,HttpServletResponse,RestException)}
					<br>Gets called when an error occurs on a request call.
					<br>Default implementation logs the error.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#renderError(HttpServletRequest,HttpServletResponse,RestException) renderError(HttpServletRequest,HttpServletResponse,RestException)}
					<br>Method that produces the error message on the HTTP response.
				<li class='m'>{@link com.ibm.juno.server.RestServlet#handleNotFound(int,RestRequest,RestResponse) handleNotFound(int,RestRequest,RestResponse)}
					<br>Method that gets called when no method/path pattern match the incoming request.

			</ul>
		</ul>
		<p>
			The following convenience methods are provided for logging:
		</p>
		<ul class='javahierarchy'>
			<li class='a'>{@link com.ibm.juno.server.RestServlet}
			<ul>
				<li class='m'>{@link com.ibm.juno.server.RestServlet#getLogger() getLogger()}
				<li class='m'>{@link com.ibm.juno.server.RestServlet#log(Level,String,Object[]) log(Level,String,Object[])}
				<li class='m'>{@link com.ibm.juno.server.RestServlet#log(Level,Throwable,String,Object[]) log(Level,Throwable,String,Object[])}
				<li class='m'>{@link com.ibm.juno.server.RestServlet#logObjects(Level,String,Object[]) logObject(Level,String,Object[])}
			</ul>
		</ul>
		<p>
			The <l>logObjects()</l> method is particularly useful because it allows you to pass in POJOs as arguments
				that serialized using {@link com.ibm.juno.core.json.JsonSerializer#DEFAULT_LAX_READABLE}, but only
				if the message is actually logged.
		</p>
		<h6 class='figure'>Example:</h6>
		<p class='bcode'>
	logObjects(<jsf>DEBUG</jsf>, <js>"Pojo contents:\n{0}"</js>, myPojo);
		</p>
		<p>
			The Juno framework uses the built-in Java Logging API for logging.
		</p>
		<p>
			If your application makes use of Apache Commons Logging or some other logging API, you can override the 
				{@link com.ibm.juno.server.RestServlet#log(Level,String,Object[])} method to 
				provide a bridge between the two frameworks.
		</p>
		<p class='bcode'>
	<ja>@Override</ja> <jc>/* RestServlet */</jc>
	<jk>protected void</jk> log(Level level, Throwable cause, String msg, Object...args) {
		Log log = getApacheCommonsLog();
		<jk>if</jk> (level == Level.<jsf>SEVERE</jsf>)
			log.error(msg, cause, args);
		<jk>else if</jk> (level == Level.<jsf>WARNING</jsf>)
        	log.warn(msg, cause, args);
		<jk>else if</jk> (level == Level.<jsf>INFO</jsf>)
        	log.info(msg, cause, args);
		<jk>else</jk> 
        	log.debug(msg, cause, args);
	}
		</p>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.ConfigFile"></a>
	<h3 class='topic' onclick='toggle(this)'>4.20 - Configuration Files</h3>
	<div class='topic'>
		<p>
			The Juno Configuration API is an entirely separate topic from the REST support.
			But the Server API provides methods for associating configuration files 
				with REST servlets so that configuration properties can be defined in external files.
		</p>
		<p>
			The Configuration API provides support for INI-style configuration files with embedded string variables:
		</p>
		<h6 class='topic'>Example:</h6>
		<p class='bcode'>
	<cc>#--------------------------</cc>
	<cc># Examples </cc>
	<cc>#--------------------------</cc>
	<cs>[MyProperties]</cs>
	<ck>path</ck> = <cv>$E{PATH}</cv>
	<ck>javaHome</ck> = <cv>$S{java.home}</cv>
	<ck>customMessage</ck> = <cv>Java home is $C{MyProperties/javaHome} and the environment path is $C{MyProperties/path}.</cv>
		</p>
		<p>
			These properties are then accessible through the {@link com.ibm.juno.core.ini.ConfigFile} class.
		</p>
		<p class='bcode'>
	ConfigFile cf = ConfigMgr.<jsf>INSTANCE</jsf>.getConfigFile(<js>"myconfig.cfg"</js>);
	String path = cf.getString(<js>"MyProperties/path"</js>);
	File javaHome = cf.getObject(File.<jk>class</jk>, <js>"MyProperties/javaHome"</js>);
	String customMessage = cf.getString(<js>"MyProperties/customMessage"</js>);
		</p>
		<p>
			Configuration files are associated with REST servlets through the {@link com.ibm.juno.server.annotation.RestResource#config() @RestResource.config()}
				annotation.
		</p>
		<h6 class='topic'>Example:</h6>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		<jc>// Config file is located at ./config_dir/myconfig.cfg</jc>
		config=<js>"config_dir/myconfig.cfg"</js>,
		...
	)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		</p>
		<p>
			The annotation itself can contain string variables.  
			For example, the Microservice API {@link com.ibm.juno.microservice.Resource} class defines the location of the config file as a 
				system property <l>"juno.configFile"</l>:
		</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		<jc>// Config file location is defined as a system property</jc>
		config=<js>"$S{juno.configFile}"</js>,
		...
	)
	<jk>public abstract class</jk> Resource <jk>extends</jk> RestServletDefault {
		</p>
		<p>
			In that particular case, the system property can either be passed in, or be determined programmatically
				based on the jar file name in the {@link com.ibm.juno.microservice.Microservice} class.
			It should be noted that the Configuration API is used extensively in the Microservice API in order to externally configure microservices.
		</p>
		<p>
			Once a config file has been associated with a REST servlet, it can be accessed through the {@link com.ibm.juno.server.RestServlet#getConfig()}
				method.
		</p>
		<p>
			A common usage is to use this method to initialize fields in your servlet.
		</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		<jc>// Config file is located at ./config_dir/myconfig.cfg</jc>
		config=<js>"config_dir/myconfig.cfg"</js>,
		...
	)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		<jk>private</jk> String path = getConfig().getString(<js>"MyProperties/path"</js>);
		<jk>private</jk> File javaHome = getConfig().getObject(File.<jk>class</jk>, <js>"MyProperties/javaHome"</js>);
		</p>
		<p>
			Another common usage is to refer to config properties through <ck>$C</ck> variables in your annotations:
		</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		<jc>// Get stylesheet from myconfig.cfg, but default to juno.css if it's not specified</jc>
		stylesheet=<js>"$C{MyServlet/stylesheet,styles/juno.css}"</js>,
		...
	)
	<jk>public</jk> MyRestServlet <jk>extends</jk> RestServlet {
		</p>
		<p>
			It's even possible to reference request-level variables in your config file if you use {@link com.ibm.juno.server.RestRequest#getConfig()}
				to access the config file:
		</p>
		<p class='bcode'>
	<cc>#-------------------------------------</cc>
	<cc># Contents of config_dir/myconfig.cfg </cc>
	<cc>#-------------------------------------</cc>
	<cs>[HelloWorldResource]</cs>
	<ck>defaultPerson</ck> = you
	<ck>message</ck> = <cv>Hello $P{person,$C{HelloWorldResource/defaultPerson}}!</cv>
		</p>
		<p class='bcode'>
	<jd>/** 
	 * Sample REST resource that prints out a simple "Hello world!" message.
	 */</jd>
	 <ja>@RestResource</ja>(
	 	config=<js>"config_dir/myconfig.cfg"</js>,
	 	...
	 )
 	<jk>public class</jk> HelloWorldResource <jk>extends</jk> RestServletDefault {
		
		<jd>/** 
		 * GET request handler.
		 * Specify the GET parameter "?person=X" for a specialized message! 
		 */</jd>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>)
		<jk>public</jk> String sayHello(RestRequest req) {
			<jk>return</jk> req.getConfig().getString(<js>"HelloWorldResource/message"</js>);
		}
	}
		</p>
		<p>
			You can even add resource bundles into the mix:
		</p>
		<p class='bcode'>
	<cc>#-------------------------------------</cc>
	<cc># Contents of config_dir/myconfig.cfg </cc>
	<cc>#-------------------------------------</cc>
	<cs>[HelloWorldResource]</cs>
	<ck>defaultPerson</ck> = you
	<ck>message</ck> = <cv>$L{localizedMessage,$P{person,$C{HelloWorldResource/defaultPerson}}}</cv>
		</p>
		<p class='bcode'>
	<cc>#-------------------------------------------</cc>
	<cc># Contents of HelloWorldResource.properties </cc>
	<cc>#-------------------------------------------</cc>
	<ck>localizedMessage</ck> = <cv>Hello {0}!</cv>
		</p>
		<p class='bcode'>
	<jd>/** 
	 * Sample REST resource that prints out a simple "Hello world!" message.
	 */</jd>
	 <ja>@RestResource</ja>(
	 	messages=<js>"HelloWorldResources"</js>,
	 	config=<js>"config_dir/myconfig.cfg"</js>,
	 	...
	 )
 	<jk>public class</jk> HelloWorldResource <jk>extends</jk> RestServletDefault {
		
		<jd>/** 
		 * GET request handler.
		 * Specify the GET parameter "?person=X" for a specialized message! 
		 */</jd>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>)
		<jk>public</jk> String sayHello(RestRequest req) {
			<jk>return</jk> req.getConfig().getString(<js>"HelloWorldResource/message"</js>);
		}
	}
		</p>
		<h6 class='topic'>Additional Information</h6>
		<ul class='javahierarchy'>
			<li class='p'><a href='../core/ini/package-summary.html#TOC'><l>com.ibm.juno.core.ini</l></a>
				<br>Juno Configuration API Javadocs.
			<li class='p'><a href='../microservice/package-summary.html#TOC'><l>com.ibm.juno.microservice</l></a>
				<br>Juno Microservice API Javadocs.
			<li class='m'>{@link com.ibm.juno.server.RestServlet#getConfig()}
			<li class='m'>{@link com.ibm.juno.server.RestServlet#getConfigMgr()}
		</ul>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.Inheritence"></a>
	<h3 class='topic' onclick='toggle(this)'>4.21 - Annotation Inheritence</h3>
	<div class='topic'>
		<p>
			The <ja>@RestResource</ja> annotation can be used on parent classes and interfaces.
			When multiple annotations are defined at different levels, the annotation values
				are combined.
			Child annotation values always take precedence over parent annotation values.
		</p>
		<table class='styled'>
			<tr>
				<th><l>Annotation</l></th>
				<th><l>Inheritence Rules</l></th>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#guards() guards()}</td>
				<td>
					Guards on child are combined with those on parent class.
					<br>Guards are executed child-to-parent in the order they appear in the annotation.
					<br>Guards on methods are executed before those on classes.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#converters() converters()}</td>
				<td>
					Converters on child are combined with those on parent class.
					<br>Converters are executed child-to-parent in the order they appear in the annotation.
					<br>Converters on methods are executed before those on classes.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#filters() filters()}</td>
				<td>
					Filters on child are combined with those on parent class.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#properties() properties()}</td>
				<td>
					Properties on child are combined with those on parent class.
					<br>Properties are applied parent-to-child in the order they appear in the annotation.
					<br>Properties on methods take precedence over those on classes.				
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#serializers() serializers()}</td>
				<td>
					Serializers on child are combined with those on parent class.
					<br>Serializers on methods take precedence over those on classes.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#parsers() parsers()}</td>
				<td>
					Parsers on child are combined with those on parent class.
					<br>Parsers on methods take precedence over those on classes.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#responseHandlers() responseHandlers()}</td>
				<td>
					Response handlers on child are combined with those on parent class.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#encoders() encoders()}</td>
				<td>
					Encoders on child are combined with those on parent class.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#defaultRequestHeaders() defaultRequestHeaders()}</td>
				<td>
					Headers on child are combined with those on parent class.
					<br>Headers are applied parent-to-child in the order they appear in the annotation.
					<br>Headers on methods take precedence over those on classes.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#defaultResponseHeaders() defaultResponseHeaders()}</td>
				<td>
					Headers on child are combined with those on parent class.
					<br>Headers are applied parent-to-child in the order they appear in the annotation.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#children() children()}</td>
				<td>
					Children on child are combined with those on parent class.
					<br>Children are list parent-to-child in the order they appear in the annotation.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#path() path()}</td>
				<td>
					Path is searched for in child-to-parent order.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#label() label()}</td>
				<td>
					Label is searched for in child-to-parent order.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#description() description()}</td>
				<td>
					Description is searched for in child-to-parent order.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#config() config()}</td>
				<td>
					Config file is searched for in child-to-parent order.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#stylesheet() stylesheet()}</td>
				<td>
					Stylesheet is searched for in child-to-parent order.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#favicon() favicon()}</td>
				<td>
					Favicon is searched for in child-to-parent order.
				</td>
			</tr>
			<tr>
				<td>{@link com.ibm.juno.server.annotation.RestResource#staticFiles() staticFiles()}</td>
				<td>
					Static files on child are combined with those on parent class.
					<br>Static files are are executed child-to-parent in the order they appear in the annotation.
				</td>
			</tr>
		</table>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.HttpStatusCodes"></a>
	<h3 class='topic' onclick='toggle(this)'>4.22 - HTTP Status Codes</h3>
	<div class='topic'>
		<p>
			By default, a 200 (OK) status is automatically set as the HTTP status when a Java method executes successfully.
		</p>
		<p>
			Other status codes can be generated by throwing a {@link com.ibm.juno.server.RestException} with a specific HTTP status code, 
				or calling {@link javax.servlet.http.HttpServletResponse#setStatus(int)}.
		</p>
		<p>
			Non-OK (200) status codes are automatically triggered by the following...
		</p>
		<table class='styled'>
			<tr>
				<th><l>Code</l></th>
				<th><l>Description</l></th>
				<th><l>When triggered</l></th>
			</tr>
			<tr>
				<td><l>401</l></td>
				<td>Unauthorized</td>
				<td>A {@link com.ibm.juno.server.RestGuard guard} prevented the method from being executed</td>
			</tr>
			<tr>
				<td><l>404</l></td>
				<td>Not Found</td>
				<td>No matching path patterns were found on any method</td>
			</tr>
			<tr>
				<td><l>405</l></td>
				<td>Method Not Implemented</td>
				<td>A path pattern matched, but no Java methods were found for the HTTP method</td>
			</tr>
			<tr>
				<td><l>406</l></td>
				<td>Not Acceptable</td>
				<td>A path pattern matched, but no Java methods were found with a matching serializer for the <l>Accept</l> on the request</td>
			</tr>
			<tr>
				<td><l>412</l></td>
				<td>Precondition Failed</td>
				<td>A path pattern matched, but no Java methods were found that were not rejected by {@link com.ibm.juno.server.RestMatcher matchers}</td>
			</tr>
			<tr>
				<td><l>415</l></td>
				<td>Unsupported Media Type</td>
				<td>A path pattern matched, but no Java methods were found with a matching parser for the <l>Content-Type</l> on the request</td>
			</tr>
			<tr>
				<td><l>500</l></td>
				<td>Internal Server Error</td>
				<td>The Java method threw an exception other than {@link com.ibm.juno.server.RestException}</td>
			</tr>
		</table>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.OverloadedHttpMethods"></a>
	<h3 class='topic' onclick='toggle(this)'>4.23 - Overloaded HTTP Methods</h3>
	<div class='topic'>
		<p>
			Through the use of the built-in <l>"method"</l> GET parameter, you can implement requests beyond the basic REST http method types.
		</p>
		<p>
			For example, the URL <l>"/sample/foo?method=BAR"</l> will cause the following method to be invoked...
		</p>
		<p class='bcode'>
	<ja>@RestMethod</ja>(name=<js>"BAR"</js>)
	<jk>public void</jk> doBar(RestRequest req, RestResponse res) {
		<jc>// Handle BAR requests</jc>
	}
		</p>
		<p>
			To support overloaded methods, the {@link com.ibm.juno.server.RestServletProperties#REST_allowMethodParam} property
				must be set on your servlet.
		</p>
		<p class='bcode'>
	<ja>@RestResource</ja>(
		properties={
			<jc>// Allow &method parameter on BAR requests</jc>
			<ja>@Property</ja>(name=<jsf>REST_allowMethodParam</jsf>, value=<js>"BAR"</js>)
		},
	)
		</p>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.BuildInParams"></a>
	<h3 class='topic' onclick='toggle(this)'>4.24 - Built-In Parameters</h3>
	<div class='topic'>
		<p>
			The following URL parameters have special meaning and can be passed in through the URL of the request:
		</p>
		<table class='styled'>
			<tr>
				<th><l>GET Parameter</l></th>
				<th><l>Description</l></th>
			</tr>
			<tr>
				<td class='code'>&amp;plainText=true</td>
				<td>
					Response will always be <l>Content-Type: text/plain</l> and the returned text will be human-readable
						(i.e. {@link com.ibm.juno.core.serializer.SerializerProperties#SERIALIZER_useIndentation} and 
						{@link com.ibm.juno.core.json.JsonSerializerProperties#JSON_useWhitespace} enabled).
					<br>Useful for debugging.
				</td>
			</tr>
			<tr>
				<td class='code'>&amp;debug=true</td>
				<td>
				Request body content will be dumped to log file.
				</td>
			</tr>
			<tr>
				<td class='code'>&amp;noTrace=true</td>
				<td>
					If an error occurs, don't log the stack trace to the log file.
					<br>Useful for automated JUnit testcases testing error states to prevent the log file from filling up with
						useless stack traces.
				</td>
			</tr>
			<tr>
				<td class='code'>&amp;method=X</td>
				<td>
					Overload the HTTP method as a GET parameter (e.g <l>"POST"</l>).
					<br>Must be enabled via {@link com.ibm.juno.server.RestServletProperties#REST_allowMethodParam} property.
				</td>
			</tr>
			<tr>
				<td class='code'>&amp;X=headerValue</td>
				<td>
					Specify a header value as a GET parameter.
					<br>Must be enabled via {@link com.ibm.juno.server.RestServletProperties#REST_allowHeaderParams} property.
				</td>
			</tr>
			<tr>
				<td class='code'>&amp;content=X</td>
				<td>
					Pass in the HTTP body content on PUT and POST methods as a UON-encoded GET parameter.
					<br>
					<br>Must be enabled via {@link com.ibm.juno.server.RestServletProperties#REST_allowContentParam} property.
				</td>
			</tr>
		</table>
	</div>
	
	<!-- ======================================================================================================== -->
	<a name="RestResources.CustomSerializersParsers"></a>
	<h3 class='topic' onclick='toggle(this)'>4.25 - Defining your own serializers/parsers</h3>
	<div class='topic'>
		<p>
			A very easy-to-use API is provided for defining your own serializers and parsers at both the servlet and method levels.
		</p>
		<p>
			The following examples show a custom serializer and parser defined at the method level.
			It's the <l>PhotosResource</l> class pulled from the Samples project.
			It shows an example of defining a serializer and parser to handle images.
		</p>
		<p class='bcode'>
	<jd>/**
	 * Sample resource that allows images to be uploaded and retrieved.
	 */</jd>
	<ja>@RestResource</ja>(
		path=<js>"/photos"</js>,
		messages=<js>"nls/PhotosResource"</js>,
		properties={
			<ja>@Property</ja>(name=HtmlDocSerializerProperties.<jsf>HTMLDOC_links</jsf>, value=<js>"{options:'?method=OPTIONS'}"</js>),
			<ja>@Property</ja>(name=HtmlDocSerializerProperties.<jsf>HTMLDOC_title</jsf>, value=<js>"Photo REST service"</js>),
			<ja>@Property</ja>(name=HtmlDocSerializerProperties.<jsf>HTMLDOC_description</jsf>, value=<js>"Use a tool like Poster to upload and retrieve jpeg and png images."</js>)
		}
	)
	<jk>public class</jk> PhotosResource <jk>extends</jk> RestServletDefault {
	
		<jc>// Our cache of photos</jc>
		<jk>private</jk> Map&lt;Integer,Photo&gt; photos = <jk>new</jk> TreeMap&lt;Integer,Photo&gt;();
		
		<jd>/** Bean class for storing photos */</jd>
		<jk>public static class</jk> Photo {
			<jk>private int</jk> <jf>id</jf>;
			BufferedImage <jf>image</jf>;
			
			Photo(int id, BufferedImage image) {
				<jk>this</jk>.<jf>id</jf> = id;
				<jk>this</jk>.<jf>image</jf> = image;
			}
			
			<jk>public</jk> URI getURI() <jk>throws</jk> URISyntaxException {
				<jk>return new</jk> URI(<js>"photos/"</js>+<jf>id</jf>);
			}
			
			<jk>public int</jk> getID() {
				<jk>return</jk> <jf>id</jf>;
			}
		}
		
		<jd>/** GET request handler for list of all photos */</jd>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>)
		<jk>public</jk> Collection&lt;Photo&gt; getAllPhotos(RestRequest req, RestResponse res) <jk>throws</jk> Exception {
			res.setProperty(HtmlDocSerializerProperties.<jsf>HTMLDOC_title</jsf>, <js>"Photo REST service"</js>);
			res.setProperty(HtmlDocSerializerProperties.<jsf>HTMLDOC_description</jsf>, <js>"Use a tool like Poster to upload and retrieve jpeg and png images."</js>);
			<jk>return</jk> photos.values();
		}
		
		<jd>/** GET request handler for single photo */</jd>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/{id}"</js>, serializers=ImageSerializer.<jk>class</jk>)
		<jk>public</jk> BufferedImage getPhoto(RestRequest req, <ja>@Attr</ja> int id) <jk>throws</jk> Exception {
			Photo p = photos.get(id);
			if (p == <jk>null</jk>)
				<jk>throw new</jk> RestException(<jsf>SC_NOT_FOUND</jsf>, <js>"Photo not found"</js>);
			<jk>return</jk> p.image;
		}
		
		<jd>/** PUT request handler */</jd>
		<ja>@RestMethod</ja>(name=<js>"PUT"</js>, path=<js>"/{id}"</js>, parsers=ImageParser.<jk>class</jk>)
		<jk>public</jk> String addPhoto(RestRequest req, <ja>@Attr</ja> <jk>int</jk> id, <ja>@Content</ja> BufferedImage image) <jk>throws</jk> Exception {
			photos.put(id, <jk>new</jk> Photo(id, image));
			<jk>return</jk> <js>"OK"</js>;
		}
		
		<jd>/** POST request handler */</jd>
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/"</js>, parsers=ImageParser.<jk>class</jk>)
		<jk>public</jk> Photo setPhoto(RestRequest req, <ja>@Content</ja> BufferedImage image) <jk>throws</jk> Exception {
			<jk>int</jk> id = photos.size();
			Photo p = <jk>new</jk> Photo(id, image);
			photos.put(id, p);
			<jk>return</jk> p;
		}
		
		<jd>/** DELETE request handler */</jd>
		<ja>@RestMethod</ja>(name=<js>"DELETE"</js>, path=<js>"/{id}"</js>)
		<jk>public</jk> String deletePhoto(RestRequest req, <ja>@Attr</ja> <jk>int</jk> id) <jk>throws</jk> Exception {
			Photo p = photos.remove(id);
			if (p == <jk>null</jk>)
				<jk>throw new</jk> RestException(<jsf>SC_NOT_FOUND</jsf>, <js>"Photo not found"</js>);
			<jk>return</jk> <js>"OK"</js>;
		}
	
		<jd>/** OPTIONS request handler */</jd>
		<ja>@RestMethod</ja>(name=<js>"OPTIONS"</js>, path=<js>"/*"</js>)
		<jk>public</jk> ResourceOptions doOptions(RestRequest req) {
			<jk>return new</jk> ResourceOptions(<jk>this</jk>, req);
		}

		<jd>/** Serializer for converting images to byte streams */</jd>
		<ja>@Produces</ja>({<js>"image/png"</js>,<js>"image/jpeg"</js>})
		<jk>public static class</jk> ImageSerializer <jk>extends</jk> OutputStreamSerializer {
			<ja>@Override</ja>
			<jk>public void</jk> serialize(Object o, OutputStream out, SerializerContext ctx) <jk>throws</jk> IOException, SerializeException {
				RenderedImage image = (RenderedImage)o;
				String mediaType = ctx.getMediaType();
				ImageIO.<jsm>write</jsm>(image, mediaType.substring(mediaType.indexOf(<js>'/'</js>)+1), out);
			}	
		}
		
		<jd>/** Parser for converting byte streams to images */</jd>
		<ja>@Consumes</ja>({<js>"image/png"</js>,<js>"image/jpeg"</js>})
		<jk>public static class</jk> ImageParser <jk>extends</jk> InputStreamParser {
			<ja>@Override</ja>
			<jk>public</jk> &lt;T&gt; T parse(InputStream in, ClassMeta&lt;T&gt; type, ParserContext ctx) <jk>throws</jk> ParseException, IOException {
				BufferedImage image = ImageIO.<jsm>read</jsm>(in);
				<jk>return</jk> (T)image;
			}
		}
	}
		</p>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.ResponseHandlers"></a>
	<h3 class='topic' onclick='toggle(this)'>4.26 - Response Handlers</h3>
	<div class='topic'>
		<p>
			Juno uses {@link com.ibm.juno.server.ResponseHandler ResponseHandlers} to convert POJOS returned by REST 
				methods to proper HTTP responses.
		</p>
		<p>
			Juno comes with the following response handlers out-of-the-box:
		</p>
		<ul class='javahierarchy'>
			<li class='i'>{@link com.ibm.juno.server.ResponseHandler}
			<ul>
				<li class='c'>{@link com.ibm.juno.server.response.DefaultHandler}
					<br>The default handler for POJOs that convert them to output using the Juno serializers.
				<li class='c'>{@link com.ibm.juno.server.response.ReaderHandler}
					<br>Pipes {@link java.io.Reader Readers} directly to the response stream.  
				<li class='c'>{@link com.ibm.juno.server.response.InputStreamHandler}
					<br>Pipes {@link java.io.InputStream InputStream} directly to the response stream.  
				<li class='c'>{@link com.ibm.juno.server.response.RedirectHandler}
					<br>Handles {@link com.ibm.juno.server.Redirect} objects that perform HTTP redirection (<l>HTTP 302</l>).
				<li class='c'>{@link com.ibm.juno.server.response.WritableHandler}
					<br>Handles {@link com.ibm.juno.core.Writable} objects.
				<li class='c'>{@link com.ibm.juno.server.response.StreamableHandler}
					<br>Handles {@link com.ibm.juno.core.Streamable} objects.
				<li class='c'>{@link com.ibm.juno.server.response.ZipFileListResponseHandler}
					<br>Handles {@link com.ibm.juno.core.utils.ZipFileList} objects.
			</ul>
		</ul>
		<p>
			The list of response handlers can be modified or augmented in one of the following ways:
		</p>
		<ul class='spaced-list'>
			<li>Specifying additional handlers through the {@link com.ibm.juno.server.annotation.RestResource#responseHandlers() @RestResource.responseHandlers()} annotation.
			<li>Overriding and extending the {@link com.ibm.juno.server.RestServlet#createResponseHandlers()} method.
		</ul>
		<p>
			The {@link com.ibm.juno.server.RestServlet#handleResponse(RestRequest,RestResponse,Object)} method can also be 
				overridden to bypass the response handler API and process the POJO yourself.
		</p>
	</div>

	<!-- ======================================================================================================== -->
	<a name="RestResources.OtherNotes"></a>
	<h3 class='topic' onclick='toggle(this)'>4.27 - Other Notes</h3>
	<div class='topic'>
		<ul class='spaced-list'>
			<li>Subclasses can use either {@link javax.servlet.http.HttpServlet#init(ServletConfig)} 
					or {@link javax.servlet.http.HttpServlet#init()} for initialization
					just like any other servlet.
			<li>The {@link com.ibm.juno.core.serializer.SerializerProperties#SERIALIZER_relativeUriBase} property is automatically 
					set to the context root (e.g. <l>"/mycontextroot"</l>) of the web application during servlet initialization.
				This value can be overridden through the {@link com.ibm.juno.server.annotation.RestResource#properties() @RestResource.properties()} 
					or {@link com.ibm.juno.server.annotation.RestMethod#properties() @RestMethod.properties()} annotations, or through 
					{@link com.ibm.juno.server.RestResponse#setProperty(String, Object)}.
			<li>The {@link com.ibm.juno.core.serializer.SerializerProperties#SERIALIZER_absolutePathUriBase} property is automatically 
					set to the HTTP authority (e.g. <l>"https://myhost:9443"</l>) during each request.
				This value can be overridden through the {@link com.ibm.juno.server.annotation.RestMethod#properties() @RestMethod.properties()} annotations, 
					or through {@link com.ibm.juno.server.RestResponse#setProperty(String, Object)}.
			<li>The <l>X-Response-Headers</l> header can be used to pass through header values into the response.
				The value should be a URL-encoded map of key-value pairs.
				For example, to add a <l>"Refresh: 1"</l> header to the response to auto-refresh a page, the following parameter
					can be specified:  <l>"/sample?X-Response-Headers={Refresh=1}"</l>
		</ul>
	</div>
</div>

<!-- ======================================================================================================== -->
<a name="Osgi"></a>
<h2 class='topic' onclick='toggle(this)'>5 - Using with OSGi</h2>
<div class='topic'>
		<p>
		Since REST servlets are basically just <l>HttpServlets</l>, incorporating them into an OSGi environment
			is pretty straightforward.
		</p>
		<p>
		The following code shows how to register your REST servlets in an OSGi <l>Activator</l>:
	</p>
	<p class='bcode'>
	<jk>package</jk> com.ibm.juno.samples;
	
	<jk>import</jk> org.osgi.framework.*;
	<jk>import</jk> org.osgi.service.http.*;
	<jk>import</jk> org.osgi.util.tracker.*;
	
	<jk>import</jk> com.ibm.juno.server.samples.*;
	
	<jd>/**
	 * Activator class used when running samples as a bundle in an OSGi environment.
	 */</jd>
	<jk>public class</jk> Activator <jk>implements</jk> BundleActivator, ServiceTrackerCustomizer {
	
		<jk>private</jk> ServiceTracker <jf>httpServiceTracker</jf>;
		<jk>private</jk> BundleContext <jf>context</jf>;
	
		<ja>@Override</ja>
		<jk>public void</jk> start(BundleContext context) <jk>throws</jk> Exception {
			<jk>this</jk>.<jf>context</jf> = context;
			<jf>httpServiceTracker</jf> = <jk>new</jk> ServiceTracker(context, HttpService.<jk>class</jk>.getName(), <jk>this</jk>);
			<jf>httpServiceTracker</jf>.open();
		}
	
		<ja>@Override</ja>
		<jk>public void</jk> stop(BundleContext context) <jk>throws</jk> Exception {
			<jf>httpServiceTracker</jf>.close();
		}
	
		<ja>@Override</ja>
		<jk>public</jk> Object addingService(ServiceReference reference) {
			Object service = <jf>context</jf>.getService(reference);
	
			<jk>if</jk> (service <jk>instanceof</jk> HttpService) {
				HttpService s = (HttpService)service;
				<jk>try</jk> {
					s.registerServlet(<js>"/sample"</js>, <jk>new</jk> MyRestServlet(), <jk>null</jk>, <jk>null</jk>);
				} <jk>catch</jk> (Exception e) {
					<jk>throw new</jk> RuntimeException(e);
				}
			}
	
			<jk>return</jk> service;
		}
	
		<ja>@Override</ja>
		<jk>public void</jk> modifiedService(ServiceReference reference, Object service) {
		}
	
		<ja>@Override</ja>
		<jk>public void</jk> removedService(ServiceReference reference, Object service) {
		}
	}
		</p>
</div>

<!-- ======================================================================================================== -->
<a name="PojosConvertableFromString"></a>
<h2 class='topic' onclick='toggle(this)'>6 - POJOs Convertable From Strings</h2>
<div class='topic'>
		<p>
		Certain methods in the REST server API allow you to specify class types that can be convertable
			from <l>Strings</l> (e.g. {@link com.ibm.juno.server.RestRequest#getAttribute(String,Class)}).
		</p>
		<p>
		POJOs convertable from <l>Strings</l> have one of the following:
		</p>
	<ul class='spaced-list'>
		<li>One of the following static methods (first match wins):
		<ul>
			<li><code><jk>public static</jk> T fromString(String in);</code> (e.g. enums, <l>UUID</l>)
			<li><code><jk>public static</jk> T valueOf(String in);</code> (e.g. <l>Number</l>)
			<li><code><jk>public static</jk> T parse(String in);</code> (e.g. Java logging <l>Level</l>)
			<li><code><jk>public static</jk> T parseString(String in);</code> (e.g. <l>DatatypeConverter</l>)
			<li><code><jk>public static</jk> T forName(String in);</code> (e.g. <l>Class</l> and <l>Charset</l>)
		</ul>
		<li>A constructor that takes in a single <l>String</l>:
		<ul>
			<li><code><jk>public</jk> T(String in);</code>
		</ul>
		<li>Has a {@link com.ibm.juno.core.filter.PojoFilter} associated with the servlet
			with a filtered type of <l>String</l>.
	</ul>
</div>

<!-- ======================================================================================================== -->
<a name="AddressBookResource"></a>
<h2 class='topic' onclick='toggle(this)'>7 - Address Book Resource</h2>
<div class='topic'>
		<p>
		The <l>AddressBookResource</l> class that's found in the <l>microservice-samples-project.zip</l> file provides
			a good overall example of how to use the Juno server API with beans.
		</p>
		<p>
		When you start the microservice and point your browser to the address book, you should see the following:
		</p>
	<img class='bordered' src='doc-files/AddressBook.png'>
	<p>
		Use the built-in <l>Accept</l> GET parameter to simulate different language requests, such as JSON:
		</p>
	<img class='bordered' src='doc-files/AddressBookJson.png'>
		<p>
		The source for this class is shown below:
		</p>
	<h6 class='figure'>AddressBookResource.java</h6>
		<p class='bcode'>
	<jd>/** 
	* Proof-of-concept resource that shows off the capabilities of working with POJO resources. 
	* Consists of an in-memory address book repository. 
	*/</jd> 
	<ja>@RestResource</ja>( 
		path=<js>"/addressBook"</js>, 
		messages=<js>"nls/AddressBookResource"</js>, 
		properties={ 
			<ja>@Property</ja>(name=<jsf>REST_allowMethodParam</jsf>, value=<js>"*"</js>), 
			<ja>@Property</ja>(name=<jsf>HTML_uriAnchorText</jsf>, value=<jsf>TO_STRING</jsf>), 
			<ja>@Property</ja>(name=<jsf>SERIALIZER_quoteChar</jsf>, value=<js>"'"</js>), 
			<ja>@Property</ja>(name=<jsf>RDF_rdfxml_tab</jsf>, value=<js>"5"</js>), 
			<ja>@Property</ja>(name=<jsf>RDF_addRootProperty</jsf>, value=<js>"true"</js>), 
			<ja>@Property</ja>(name=<jsf>HTMLDOC_links</jsf>, value=<js>"{up:'$R{requestParentURI}',options:'$R{servletURI}?method=OPTIONS',source:'$R{servletParentURI}/source?classes=(com.ibm.juno.server.samples.addressbook.AddressBookResource,com.ibm.juno.samples.addressbook.Address,com.ibm.juno.samples.addressbook.AddressBook,com.ibm.juno.samples.addressbook.CreateAddress,com.ibm.juno.samples.addressbook.CreatePerson,com.ibm.juno.samples.addressbook.IAddressBook,com.ibm.juno.samples.addressbook.Person)'}"</js>), 
			<jc>// Resolve all relative URIs so that they're relative to this servlet!</jc> 
			<ja>@Property</ja>(name=<jsf>SERIALIZER_relativeUriBase</jsf>, value=<js>"$R{servletURI}"</js>), 
		}, 
		encoders=GzipEncoder.<jk>class</jk> 
	) 
	<jk>public class</jk> AddressBookResource <jk>extends</jk> ResourceJena { 
		<jk>private static final long</jk> <jsf>serialVersionUID</jsf> = 1L; 
		
		<jc>// The in-memory address book</jc> 
		<jk>private</jk> AddressBook <jf>addressBook</jf>; 
		
		<ja>@Override</ja> /* Servlet */ 
		<jk>public void</jk> init() { 
		
			<jk>try</jk> { 
				<jc>// Create the address book</jc> 
				<jf>addressBook</jf> = <jk>new</jk> AddressBook(java.net.URI.create(<js>""</js>)); 
				
				<jc>// Add some people to our address book by default</jc> 
				<jf>addressBook</jf>.createPerson( 
					<jk>new</jk> CreatePerson( 
		<js>"Barack Obama"</js>, 
		<jsm>toCalendar</jsm>(<js>"Aug 4, 1961"</js>),
		<jk>new</jk> CreateAddress(<js>"1600 Pennsylvania Ave"</js>, <js>"Washington"</js>, <js>"DC"</js>, 20500, <jk>true</jk>),
		<jk>new</jk> CreateAddress(<js>"5046 S Greenwood Ave"</js>, <js>"Chicago"</js>, <js>"IL"</js>, 60615, <jk>false</jk>)
					) 
	); 
				<jf>addressBook</jf>.createPerson( 
					<jk>new</jk> CreatePerson( 
		<js>"George Walker Bush"</js>, 
						<jsm>toCalendar</jsm>(<js>"Jul 6, 1946"</js>), 
						<jk>new</jk> CreateAddress(<js>"43 Prairie Chapel Rd"</js>, <js>"Crawford"</js>, <js>"TX"</js>, 76638, <jk>true</jk>), 
						<jk>new</jk> CreateAddress(<js>"1600 Pennsylvania Ave"</js>, <js>"Washington"</js>, <js>"DC"</js>, 20500, <jk>false</jk>) 
					) 
	);
			
			} <jk>catch</jk> (Exception e) { 
				<jk>throw new</jk> RuntimeException(e); 
			} 
		} 
		
		<jd>/** 
		* [GET /] 
		* Get root page. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/"</js>, 
			converters=Queryable.<jk>class</jk> 
		) 
		<jk>public</jk> Link[] getRoot() <jk>throws</jk> Exception { 
			<jk>return new</jk> Link[] { 
				<jk>new</jk> Link(<js>"people"</js>, <js>"people"</js>), 
				<jk>new</jk> Link(<js>"addresses"</js>, <js>"addresses"</js>) 
			}; 
		} 
		
		<jd>/** 
		* [GET /people/*] 
		* Get all people in the address book. 
		* Traversable filtering enabled to allow nodes in returned POJO tree to be addressed. 
		* Introspectable filtering enabled to allow public methods on the returned object to be invoked. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/people/*"</js>, 
			converters={Traversable.<jk>class</jk>,Queryable.<jk>class</jk>,Introspectable.<jk>class</jk>} 
		) 
		<jk>public</jk> List&lt;Person&gt; getAllPeople() <jk>throws</jk> Exception { 
			<jk>return</jk> <jf>addressBook</jf>.getPeople(); 
		} 
		
		<jd>/** 
		* [GET /people/{id}/*] 
		* Get a single person by ID. 
		* Traversable filtering enabled to allow nodes in returned POJO tree to be addressed. 
		* Introspectable filtering enabled to allow public methods on the returned object to be invoked. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/people/{id}/*"</js>, 
			converters={Traversable.<jk>class</jk>,Queryable.<jk>class</jk>,Introspectable.<jk>class</jk>} 
		) 
		<jk>public</jk> Person getPerson(<ja>@Attr</ja> <jk>int</jk> id) <jk>throws</jk> Exception { 
			<jk>return</jk> findPerson(id); 
		} 
		
		<jd>/** 
		* [GET /addresses/*] 
		* Get all addresses in the address book. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/addresses/*"</js>, 
			converters={Traversable.<jk>class</jk>,Queryable.<jk>class</jk>} 
		) 
		<jk>public</jk> List&lt;Address&gt; getAllAddresses() <jk>throws</jk> Exception { 
			<jk>return</jk> <jf>addressBook</jf>.getAddresses(); 
		} 
		
		<jd>/** 
		* [GET /addresses/{id}/*] 
		* Get a single address by ID. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/addresses/{id}/*"</js>, 
			converters={Traversable.<jk>class</jk>,Queryable.<jk>class</jk>} 
		) 
		<jk>public</jk> Address getAddress(<ja>@Attr</ja> <jk>int</jk> id) <jk>throws</jk> Exception { 
			<jk>return</jk> findAddress(id); 
		} 
		
		<jd>/** 
		* [POST /people] 
		* Create a new Person bean. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/people"</js>, 
			guards=AdminGuard.<jk>class</jk> 
		) 
		<jk>public</jk> Redirect createPerson(<ja>@Content</ja> CreatePerson cp) <jk>throws</jk> Exception { 
		Person p = <jf>addressBook</jf>.createPerson(cp); 
			<jk>return new</jk> Redirect(<js>"people/{0}"</js>, p.id); 
		} 
		
		<jd>/** 
		* [POST /people/{id}/addresses] 
		* Create a new Address bean. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"POST"</js>, path=<js>"/people/{id}/addresses"</js>, 
			guards=AdminGuard.<jk>class</jk> 
		) 
		<jk>public</jk> Redirect createAddress(<ja>@Attr</ja> <jk>int</jk> id, <ja>@Content</ja> CreateAddress ca) <jk>throws</jk> Exception { 
			Person p = findPerson(id); 
			Address a = p.createAddress(ca); 
			<jk>return new</jk> Redirect(<js>"addresses/{0}"</js>, a.id); 
		} 
		
		<jd>/** 
		* [DELETE /people/{id}] 
		* Delete a Person bean. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"DELETE"</js>, path=<js>"/people/{id}"</js>, 
			guards=AdminGuard.<jk>class</jk>, 
		) 
		<jk>public</jk> String deletePerson(<ja>@Attr</ja> <jk>int</jk> id) <jk>throws</jk> Exception { 
			<jf>addressBook</jf>.removePerson(id); 
			<jk>return</jk> <js>"DELETE successful"</js>; 
		} 
		
		<jd>/** 
		* [DELETE /addresses/{id}] 
		* Delete an Address bean. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"DELETE"</js>, path=<js>"/addresses/{id}"</js>, 
			guards=AdminGuard.<jk>class</jk> 
		) 
		<jk>public</jk> String deleteAddress(<ja>@Attr</ja> <jk>int</jk> addressId) <jk>throws</jk> Exception { 
			Person p = <jf>addressBook</jf>.findPersonWithAddress(addressId); 
			<jk>if</jk> (p == <jk>null</jk>) 
				<jk>throw new</jk> RestException(<jsf>SC_NOT_FOUND</jsf>, <js>"Person not found"</js>); 
			Address a = findAddress(addressId); 
			p.addresses.remove(a); 
			<jk>return</jk> <js>"DELETE successful"</js>; 
		} 
		
		<jd>/** 
		* [PUT /people/{id}/*] 
		* Change property on Person bean. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"PUT"</js>, path=<js>"/people/{id}/*"</js>, 
			guards=AdminGuard.<jk>class</jk> 
		) 
		<jk>public</jk> String updatePerson(RestRequest req, <ja>@Attr</ja> <jk>int</jk> id) <jk>throws</jk> Exception { 
			<jk>try</jk> { 
				Person p = findPerson(id); 
				String pathRemainder = req.getPathRemainder(); 
				PojoRest r = <jk>new</jk> PojoRest(p); 
				ClassMeta&lt;?&gt; cm = r.getClassMeta(pathRemainder); 
				Object in = req.getInput(cm); 
				r.put(pathRemainder, in); 
				<jk>return</jk> <js>"PUT successful"</js>; 
			} <jk>catch</jk> (Exception e) { 
				<jk>throw new</jk> RestException(<jsf>SC_BAD_REQUEST</jsf>, <js>"PUT unsuccessful"</js>).initCause(e); 
			} 
		} 
		
		<jd>/** 
		* [PUT /addresses/{id}/*] 
		* Change property on Address bean. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"PUT"</js>, path=<js>"/addresses/{id}/*"</js>, 
			guards=AdminGuard.<jk>class</jk> 
		) 
		<jk>public</jk> String updateAddress(RestRequest req, <ja>@Attr</ja> <jk>int</jk> id) <jk>throws</jk> Exception { 
			<jk>try</jk> { 
				Address a = findAddress(id); 
				String pathInfo = req.getPathInfo(); 
				PojoRest r = <jk>new</jk> PojoRest(a); 
				ClassMeta&lt;?&gt; cm = r.getClassMeta(pathInfo); 
				Object in = req.getInput(cm); 
				r.put(pathInfo, in); 
				<jk>return</jk> <js>"PUT successful"</js>; 
			} <jk>catch</jk> (Exception e) { 
				<jk>throw new</jk> RestException(<jsf>SC_BAD_REQUEST</jsf>, <js>"PUT unsuccessful"</js>).initCause(e); 
			} 
		} 
		
		<jd>/** 
		* [INIT /] 
		* Reinitialize this resource. 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"INIT"</js>, path=<js>"/"</js>, 
			guards=AdminGuard.<jk>class</jk> 
		) 
		<jk>public</jk> String doInit() <jk>throws</jk> Exception { 
			init(); 
			<jk>return</jk> <js>"OK"</js>; 
		} 
		
		<jd>/** 
		* [GET /cognos] 
		* Get data in Cognos/XML format 
		*/</jd> 
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/cognos"</js>) 
		<jk>public</jk> DataSet getCognosData() <jk>throws</jk> Exception { 
		
			<jc>// The Cognos metadata</jc> 
			Column[] items = { 
				<jk>new</jk> Column(<js>"name"</js>, <js>"xs:String"</js>, 255), 
				<jk>new</jk> Column(<js>"age"</js>, <js>"xs:int"</js>), 
				<jk>new</jk> Column(<js>"numAddresses"</js>, <js>"xs:int"</js>) 
				.addFilter( 
					<jk>new</jk> PojoFilter&lt;Person,Integer&gt;() { 
						<ja>@Override</ja> /* PojoFilter */ 
						<jk>public</jk> Integer filter(Person p) { 
							<jk>return</jk> p.addresses.size(); 
						} 
					} 
				) 
			}; 
			
			<jk>return new</jk> DataSet(items, <jf>addressBook</jf>, <jk>this</jk>.getBeanContext()); 
		} 
		
		<jd>/** 
		* [OPTIONS /*] 
		* View resource options 
		*/</jd> 
		<ja>@Override</ja> /* RestServletJenaDefault */ 
		<ja>@RestMethod</ja>(name=<js>"OPTIONS"</js>, path=<js>"/*"</js>) 
		<jk>public</jk> ResourceOptions getOptions(RestRequest req) { 
			<jk>return new</jk> Options(req); 
		} 
		
		<jd>/** Convenience method - Find a person by ID */</jd> 
		<jk>private</jk> Person findPerson(<jk>int</jk> id) <jk>throws</jk> RestException { 
			Person p = <jf>addressBook</jf>.findPerson(id); 
			<jk>if</jk> (p == <jk>null</jk>) 
				<jk>throw new</jk> RestException(<jsf>SC_NOT_FOUND</jsf>, <js>"Person not found"</js>); 
			<jk>return</jk> p; 
		} 
		
		<jd>/** Convenience method - Find an address by ID */</jd> 
		<jk>private</jk> Address findAddress(<jk>int</jk> id) <jk>throws</jk> RestException { 
			Address a = <jf>addressBook</jf>.findAddress(id); 
			<jk>if</jk> (a == <jk>null</jk>) 
				<jk>throw new</jk> RestException(<jsf>SC_NOT_FOUND</jsf>, <js>"Address not found"</js>); 
			<jk>return</jk> a; 
		} 
		
		<jd>/** 
		* Output POJO for OPTIONS requests. 
		* Note that we're extending the existing ResourceOptions class. 
		*/</jd> 
		<jk>public class</jk> Options <jk>extends</jk> ResourceOptions { 
			<jk>public</jk> ParamDescription[] <jf>queryableParameters</jf>; 
			<jk>public</jk> String[] <jf>otherNotes</jf>; 
			
			<jk>public</jk> Options(RestRequest req) { 
				<jk>super</jk>(AddressBookResource.<jk>this</jk>, req); 
				Locale locale = req.getLocale(); 
				<jf>queryableParameters</jf> = getQueryableParamDescriptions(locale); 
				<jf>otherNotes</jf> = getMessage(locale, <js>"otherNotes"</js>).split(<js>"\\.\\s*"</js>); 
			} 
		} 
	} 	
		</p>
		<p>
		The generated OPTIONS page is shown below:
		</p>
	<img class='bordered' src='doc-files/AddressBookOptions.png'>
		<p>
		The OPTIONS page uses the servlet resource bundle to specify the labels so that they're internationalizable.
		</p>
	<h6 class='figure'>AddressBookResource.properties</h6>
		<p class='bcode'>
	<ck>label</ck> = <cv>AddressBook sample resource</cv>
	<ck>description</ck> = <cv>Proof-of-concept resource that shows off the capabilities of working with POJO resources</cv>
	
	<ck>getRoot</ck> = <cv>Get root page</cv>
	
	<ck>getAllPeople</ck> = <cv>Get all people in the address book</cv>
	<ck>getAllPeople.res.200.content</ck> = <cv>List&lt;Person&gt;</cv>
	
	<ck>getPerson</ck> = <cv>Get a single person by ID</cv>
	<ck>getPerson.req.attr.id</ck> = <cv>Person UUID</cv>
	<ck>getPerson.res.200.content</ck> = <cv>Person bean</cv>
	<ck>getPerson.res.404</ck> = <cv>Person ID not found</cv>
	
	<ck>getAllAddresses</ck> = <cv>Get all addresses in the address book</cv>
	<ck>getAllAddresses.res.200.content</ck> = <cv>List&lt;Address&gt;</cv>
	
	<ck>getAddress</ck> = <cv>Get a single address by ID</cv>
	<ck>getAddress.req.attr.id</ck> = <cv>Address UUID</cv>
	<ck>getAddress.res.200.content</ck> = <cv>Address bean</cv>
	<ck>getAddress.res.404</ck> = <cv>Address ID not found</cv>
	
	<ck>createPerson</ck> = <cv>Create a new Person bean </cv>
	<ck>createPerson.res.307.header.Location</ck> = <cv>URL of new person</cv>
	
	<ck>createAddress</ck> = <cv>Create a new Address bean</cv>
	<ck>createAddress.req.attr.id</ck> = <cv>Person UUID</cv>
	<ck>createAddress.res.307.header.Location</ck> = <cv>URL of new address</cv>
	
	<ck>deletePerson</ck> = <cv>Delete a Person bean</cv>
	<ck>deletePerson.req.attr.id</ck> = <cv>Person UUID</cv>
	<ck>deletePerson.res.200.content</ck> = <cv>"DELETE successful"</cv>
	<ck>deletePerson.res.404</ck> = <cv>Person ID not found</cv>
	
	<ck>deleteAddress</ck> = <cv>Delete an Address bean</cv>
	<ck>deleteAddress.req.attr.id</ck> = <cv>Address UUID</cv>
	<ck>deleteAddress.res.200.content</ck> = <cv>"DELETE successful"</cv>
	<ck>deleteAddress.res.404</ck> = <cv>Address ID not found</cv>
	
	<ck>updatePerson</ck> = <cv>Change property on Person bean</cv>
	<ck>updatePerson.req.attr.id</ck> = <cv>Person UUID</cv>
	<ck>updatePerson.req.content</ck> = <cv>Anything</cv>
	<ck>updatePerson.res.200.content</ck> = <cv>"PUT successful"</cv>
	<ck>updatePerson.res.400</ck> = <cv>Invalid object type used</cv>
	<ck>updatePerson.res.404</ck> = <cv>Person ID not found</cv>
	
	<ck>updateAddress</ck> = <cv>Change property on Address bean</cv>
	<ck>updateAddress.req.attr.id</ck> = <cv>Address UUID</cv>
	<ck>updateAddress.req.content</ck> = <cv>Anything</cv>
	<ck>updateAddress.res.200.content</ck> = <cv>"PUT successful"</cv>
	<ck>updateAddress.res.400</ck> = <cv>Invalid object type used</cv>
	<ck>updateAddress.res.404</ck> = <cv>Address ID not found</cv>
	
	<ck>doInit</ck> = <cv>Reinitialize this resource</cv>
	<ck>doInit.res.200.content</ck> = <cv>"OK"</cv>
	
	<ck>getOptions</ck> = <cv>View resource options</cv>
	
	<ck>getCognosData</ck> = <cv>Get data in Cognos/XML format</cv>
	<ck>getCognosData.res.200.content</ck> = <cv>DataSet</cv>
	
	<ck>otherNotes</ck> = <cv>GZip support enabled.  Public methods can be invoked by using the &Method URL parameter.  'text/cognos+xml' support available under root resource only</cv>
	</p>

</div>

</body>
</html>