/*******************************************************************************
 * Licensed Materials - Property of IBM
 * (c) Copyright IBM Corporation 2014, 2016. All Rights Reserved.
 *
 *  The source code for this program is not published or otherwise
 *  divested of its trade secrets, irrespective of what has been
 *  deposited with the U.S. Copyright Office.
 *******************************************************************************/
package com.ibm.juno.core.xml;

import static com.ibm.juno.core.utils.StringUtils.*;
import static com.ibm.juno.core.xml.annotation.XmlFormat.*;
import static javax.xml.stream.XMLStreamConstants.*;

import java.io.*;
import java.lang.reflect.*;
import java.util.*;

import javax.xml.stream.*;

import com.ibm.juno.core.*;
import com.ibm.juno.core.annotation.*;
import com.ibm.juno.core.filter.*;
import com.ibm.juno.core.parser.*;
import com.ibm.juno.core.xml.annotation.*;

/**
 * Parses text generated by the {@link XmlSerializer} class back into a POJO model.
 *
 *
 * <h6 class='topic'>Media types</h6>
 * <p>
 * 	Handles <code>Content-Type</code> types: <code>text/xml</code>
 *
 *
 * <h6 class='topic'>Description</h6>
 * <p>
 * 	See the {@link XmlSerializer} class for a description of Juno-generated XML.
 *
 *
 * <h6 class='topic'>Configurable properties</h6>
 * <p>
 * 	This class has the following properties associated with it:
 * <ul>
 * 	<li>{@link XmlParserProperties}
 * 	<li>{@link ParserProperties}
 * 	<li>{@link BeanContextProperties}
 * </ul>
 *
 *
 * @author James Bognar (jbognar@us.ibm.com)
 */
@SuppressWarnings({ "rawtypes", "unchecked" })
@Consumes({"text/xml","application/xml"})
public class XmlParser extends ReaderParser {

	/** Default parser, all default settings.*/
	public static final XmlParser DEFAULT = new XmlParser().lock();

	private static final int UNKNOWN=0, OBJECT=1, ARRAY=2, STRING=3, NUMBER=4, BOOLEAN=5, NULL=6;


	/** XML specific properties currently defined on this class */
	protected transient XmlParserProperties xpp = new XmlParserProperties();


	private <T> T parseAnything(ClassMeta<T> nt, XmlParserContext ctx, String currAttr, XMLStreamReader r, BeanPropertyMeta p, Object outer, boolean isRoot) throws ParseException, IOException {

		try {
			BeanContext bc = ctx.getBeanContext();
			if (nt == null)
				nt = (ClassMeta<T>)object();
			PojoFilter<T,Object> filter = (PojoFilter<T,Object>)nt.getPojoFilter();
			ClassMeta<?> ft = nt.getFilteredClassMeta();

			String wrapperAttr = (isRoot && ctx.isPreserveRootElement()) ? r.getName().getLocalPart() : null;
			String typeAttr = r.getAttributeValue(null, "type");
			int jsonType = getJsonType(typeAttr);
			String b = r.getAttributeValue(ctx.getXsiNs(), "nil");
			if (b == null)
				b = r.getAttributeValue(null, "nil");
			boolean isNull = b != null && b.equals("true");
			if (jsonType == 0) {
				try {
					String elementName = ctx.decodeString(r.getLocalName());
					if (elementName == null || elementName.equals(currAttr))
						jsonType = UNKNOWN;
					else
						jsonType = getJsonType(elementName);
				} catch (Exception e) {
					throw e;
				}
			}
			if (! ft.canCreateNewInstance(outer)) {
				String c = r.getAttributeValue(null, "_class");
				if (c != null) {
					ft = nt = (ClassMeta<T>)bc.getClassMetaFromString(c);
				}
			}
			Object o = null;

			if (jsonType == NULL) {
				r.nextTag();	// Discard end tag
				return null;
			}
			if (isNull) {
				while (true) {
					int e = r.next();
					if (e == END_ELEMENT)
						return null;
				}
			}

			if (ft.isObject()) {
				if (jsonType == OBJECT) {
					ObjectMap m = new ObjectMap(bc);
					parseIntoMap(ctx, r, m, string(), object());
					if (wrapperAttr != null)
						m = new ObjectMap(bc).append(wrapperAttr, m);
					o = m.cast();
				} else if (jsonType == ARRAY)
					o = parseIntoCollection(ctx, r, new ObjectList(bc), object());
				else if (jsonType == STRING) {
					o = ctx.decodeString(r.getElementText());
					if (ft.isChar())
						o = o.toString().charAt(0);
				}
				else if (jsonType == NUMBER)
					o = parseNumber(ctx.decodeLiteral(r.getElementText()), null);
				else if (jsonType == BOOLEAN)
					o = Boolean.parseBoolean(ctx.decodeLiteral(r.getElementText()));
				else if (jsonType == UNKNOWN)
					o = getUnknown(ctx, r);
			} else if (ft.isBoolean()) {
				o = Boolean.parseBoolean(ctx.decodeLiteral(r.getElementText()));
			} else if (ft.isCharSequence()) {
				o = ctx.decodeString(r.getElementText());
			} else if (ft.isChar()) {
				o = ctx.decodeString(r.getElementText()).charAt(0);
			} else if (ft.isMap()) {
				Map m = (ft.canCreateNewInstance(outer) ? (Map)ft.newInstance(outer) : new ObjectMap(bc));
				o = parseIntoMap(ctx, r, m, ft.getKeyType(), ft.getValueType());
				if (wrapperAttr != null)
					o = new ObjectMap(bc).append(wrapperAttr, m);
			} else if (ft.isCollection()) {
				Collection l = (ft.canCreateNewInstance(outer) ? (Collection)ft.newInstance(outer) : new ObjectList(bc));
				o = parseIntoCollection(ctx, r, l, ft.getElementType());
			} else if (ft.isNumber()) {
				o = parseNumber(ctx.decodeLiteral(r.getElementText()), (Class<? extends Number>)ft.getInnerClass());
			} else if (ft.canCreateNewInstanceFromObjectMap(outer)) {
				ObjectMap m = new ObjectMap(bc);
				parseIntoMap(ctx, r, m, string(), object());
				o = ft.newInstanceFromObjectMap(outer, m);
			} else if (ft.canCreateNewBean(outer)) {
				if (ft.getXmlMeta().getFormat() == XmlFormat.COLLAPSED) {
					String fieldName = r.getLocalName();
					BeanMap m = bc.newBeanMap(outer, ft.getInnerClass());
					BeanPropertyMeta bpm = m.getMeta().getXmlMeta().getPropertyMeta(fieldName);
					bpm.set(m, parseAnything(m.getMeta().getClassMeta(), ctx, currAttr, r, p, m.getBean(false), false));
					o = m.getBean();
				} else {
					BeanMap m = bc.newBeanMap(outer, ft.getInnerClass());
					o = parseIntoBean(ctx, r, m).getBean();
				}
			} else if (ft.isArray()) {
				ArrayList l = (ArrayList)parseIntoCollection(ctx, r, new ArrayList(), ft.getElementType());
				o = bc.toArray(ft, l);
			} else if (ft.canCreateNewInstanceFromString(outer)) {
				o = ft.newInstanceFromString(outer, ctx.decodeString(r.getElementText()));
			} else {
				throw new ParseException("Class ''{0}'' could not be instantiated.  Reason: ''{1}''", ft.getInnerClass().getName(), ft.getNotABeanReason());
			}

			if (filter != null && o != null)
				o = filter.unfilter(o, nt);

			if (outer != null)
				setParent(nt, o, outer);

			if (currAttr != null)
				setName(nt, o, currAttr);

			return (T)o;
		} catch (ParseException e) {
			throw e;
		} catch (IOException e) {
			throw e;
		} catch (RuntimeException e) {
			throw e;
		} catch (Exception e) {
			throw new ParseException("Error occurred while trying to parse class type ''{0}''", nt).initCause(e);
		}
	}

	private <K,V> Map<K,V> parseIntoMap(XmlParserContext ctx, XMLStreamReader r, Map<K,V> m, ClassMeta<K> keyType, ClassMeta<V> valueType) throws ParseException, IOException {
		BeanContext bc = ctx.getBeanContext();
		try {
			int depth = 0;
			for (int i = 0; i < r.getAttributeCount(); i++) {
				String a = r.getAttributeLocalName(i);
				// TODO - Need better handling of namespaces here.
				if (! (a.equals("type"))) {
					K key = ctx.trim(convertAttrToType(m, a, keyType));
					V value = ctx.trim(convertAttrToType(m, r.getAttributeValue(i), valueType));
					m.put(key, value);
				}
			}
			do {
				int event = r.nextTag();
				String currAttr;
				if (event == START_ELEMENT) {
					depth++;
					currAttr = ctx.decodeString(r.getLocalName());
					K key = convertAttrToType(m, currAttr, keyType);
					V value = parseAnything(valueType, ctx, currAttr, r, null, m, false);
					if (valueType.isObject() && m.containsKey(key)) {
						Object o = m.get(key);
						if (o instanceof List)
							((List)o).add(value);
						else
							m.put(key, (V)new ObjectList(o, value).setBeanContext(bc));
					} else {
						m.put(key, value);
					}
				} else if (event == END_ELEMENT) {
					depth--;
					return m;
				}
			} while (depth > 0);
			return m;
		} catch (XMLStreamException e) {
			throw new ParseException(e);
		}
	}

	private <E> Collection<E> parseIntoCollection(XmlParserContext ctx, XMLStreamReader r, Collection<E> l, ClassMeta<E> elementType) throws ParseException, IOException {
		try {
			int depth = 0;
			do {
				int event = r.nextTag();
				if (event == START_ELEMENT) {
					depth++;
					E value = parseAnything(elementType, ctx, null, r, null, l, false);
					l.add(value);
				} else if (event == END_ELEMENT) {
					depth--;
					return l;
				}
			} while (depth > 0);
			return l;
		} catch (XMLStreamException e) {
			throw new ParseException(e);
		}
	}

	private Object[] parseArgs(XmlParserContext ctx, XMLStreamReader r, ClassMeta<?>[] argTypes) throws ParseException, IOException {
		try {
			int depth = 0;
			Object[] o = new Object[argTypes.length];
			int i = 0;
			do {
				int event = r.nextTag();
				if (event == START_ELEMENT) {
					depth++;
					o[i] = parseAnything(argTypes[i], ctx, null, r, null, null, false);
					i++;
				} else if (event == END_ELEMENT) {
					depth--;
					return o;
				}
			} while (depth > 0);
			return o;
		} catch (XMLStreamException e) {
			throw new ParseException(e);
		}
	}

	private int getJsonType(String s) {
		if (s == null)
			return UNKNOWN;
		char c = s.charAt(0);
		switch(c) {
			case 'o': return (s.equals("object") ? OBJECT : UNKNOWN);
			case 'a': return (s.equals("array") ? ARRAY : UNKNOWN);
			case 's': return (s.equals("string") ? STRING : UNKNOWN);
			case 'b': return (s.equals("boolean") ? BOOLEAN : UNKNOWN);
			case 'n': {
				c = s.charAt(2);
				switch(c) {
					case 'm': return (s.equals("number") ? NUMBER : UNKNOWN);
					case 'l': return (s.equals("null") ? NULL : UNKNOWN);
				}
				//return NUMBER;
			}
		}
		return UNKNOWN;
	}

	private <T> BeanMap<T> parseIntoBean(XmlParserContext ctx, XMLStreamReader r, BeanMap<T> m) throws Exception {
		BeanMeta bMeta = m.getMeta();
		XmlBeanMeta xmlMeta = bMeta.getXmlMeta();

		for (int i = 0; i < r.getAttributeCount(); i++) {
			String key = ctx.decodeString(r.getAttributeLocalName(i));
			String val = r.getAttributeValue(i);
			BeanPropertyMeta bpm = xmlMeta.getPropertyMeta(key);
			if (bpm == null) {
				if (m.getMeta().isSubTyped()) {
					m.put(key, val);
				} else {
					Location l = r.getLocation();
					onUnknownProperty(ctx, key, m, l.getLineNumber(), l.getColumnNumber());
				}
			} else {
				bpm.set(m, val);
			}
		}

		BeanPropertyMeta cp = xmlMeta.getXmlContentProperty();
		if (cp != null) {
			XmlContentHandler h = xmlMeta.getXmlContentHandler();
			if (h != null) {
				h.parse(r, m.getBean());
			} else {
				String text = r.getElementText();
				cp.set(m, ctx.decodeString(text));
			}
			return m;
		}

		int depth = 0;
		do {
			int event = r.nextTag();
			String currAttr;
			if (event == START_ELEMENT) {
				depth++;
				currAttr = ctx.decodeString(r.getLocalName());
				BeanPropertyMeta pMeta = xmlMeta.getPropertyMeta(currAttr);
				if (pMeta == null) {
					if (m.getMeta().isSubTyped()) {
						m.put(currAttr, parseAnything(ctx.getBeanContext().string(), ctx, currAttr, r, null, m.getBean(false), false));
					} else {
						Location l = r.getLocation();
						onUnknownProperty(ctx, currAttr, m, l.getLineNumber(), l.getColumnNumber());
						skipCurrentTag(r);
					}
				} else {
					XmlFormat xf = pMeta.getXmlMeta().getXmlFormat();
					if (xf == COLLAPSED) {
						pMeta.add(m, parseAnything(pMeta.getClassMeta().getElementType(), ctx, currAttr, r, null, m.getBean(false), false));
					} else if (xf == ATTR)  {
						pMeta.set(m, ctx.decodeString(r.getAttributeValue(0)));
						r.nextTag();
					} else {
						pMeta.set(m, parseAnything(pMeta.getClassMeta(), ctx, currAttr, r, pMeta, m.getBean(false), false));
					}
				}
			} else if (event == END_ELEMENT) {
				depth--;
				return m;
			}
		} while (depth > 0);
		return m;
	}

	private void skipCurrentTag(XMLStreamReader r) throws XMLStreamException {
		int depth = 1;
		do {
			int event = r.next();
			if (event == START_ELEMENT)
				depth++;
			else if (event == END_ELEMENT)
				depth--;
		} while (depth > 0);
	}

	private Object getUnknown(XmlParserContext ctx, XMLStreamReader r) throws Exception {
		BeanContext bc = ctx.getBeanContext();
		if (r.getEventType() != XMLStreamConstants.START_ELEMENT) {
			throw new XMLStreamException("parser must be on START_ELEMENT to read next text", r.getLocation());
		}
		ObjectMap m = null;

		// If this element has attributes, then it's always an ObjectMap.
		if (r.getAttributeCount() > 0) {
			m = new ObjectMap(bc);
			for (int i = 0; i < r.getAttributeCount(); i++) {
				String key = ctx.decodeString(r.getAttributeLocalName(i));
				String val = r.getAttributeValue(i);
				if (! key.equals("type"))
					m.put(key, val);
			}
		}
		int eventType = r.next();
		StringBuilder sb = new StringBuilder();
		while (eventType != XMLStreamConstants.END_ELEMENT) {
			if (eventType == XMLStreamConstants.CHARACTERS || eventType == XMLStreamConstants.CDATA || eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.ENTITY_REFERENCE) {
				sb.append(r.getText());
			} else if (eventType == XMLStreamConstants.PROCESSING_INSTRUCTION || eventType == XMLStreamConstants.COMMENT) {
				// skipping
			} else if (eventType == XMLStreamConstants.END_DOCUMENT) {
				throw new XMLStreamException("Unexpected end of document when reading element text content", r.getLocation());
			} else if (eventType == XMLStreamConstants.START_ELEMENT) {
				// Oops...this has an element in it.
				// Parse it as a map.
				if (m == null)
					m = new ObjectMap(bc);
				int depth = 0;
				do {
					int event = (eventType == -1 ? r.nextTag() : eventType);
					String currAttr;
					if (event == START_ELEMENT) {
						depth++;
						currAttr = ctx.decodeString(r.getLocalName());
						String key = convertAttrToType(null, currAttr, string());
						Object value = parseAnything(object(), ctx, currAttr, r, null, null, false);
						if (m.containsKey(key)) {
							Object o = m.get(key);
							if (o instanceof ObjectList)
								((ObjectList)o).add(value);
							else
								m.put(key, new ObjectList(o, value).setBeanContext(bc));
						} else {
							m.put(key, value);
						}

					} else if (event == END_ELEMENT) {
						depth--;
						break;
					}
					eventType = -1;
				} while (depth > 0);
				break;
			} else {
				throw new XMLStreamException("Unexpected event type " + eventType, r.getLocation());
			}
			eventType = r.next();
		}
		String s = sb.toString();
		s = ctx.decodeString(s);
		if (m != null) {
			if (! s.isEmpty())
				m.put("contents", s);
			return m;
		}
		return s;
	}


	//--------------------------------------------------------------------------------
	// Overridden methods
	//--------------------------------------------------------------------------------

	@Override /* Parser */
	public XmlParserContext createContext(ObjectMap properties, Method javaMethod, Object outer) {
		return new XmlParserContext(getBeanContext(), pp, xpp, properties, javaMethod, outer);
	}

	@Override /* Parser */
	protected <T> T doParse(Reader in, int estimatedSize, ClassMeta<T> type, ParserContext ctx) throws ParseException, IOException {
		type = ctx.getBeanContext().normalizeClassMeta(type);
		XmlParserContext xctx = (XmlParserContext)ctx;
		return parseAnything(type, xctx, null, xctx.getReader(in, estimatedSize), null, ctx.getOuter(), true);
	}

	@Override /* ReaderParser */
	protected <K,V> Map<K,V> doParseIntoMap(Reader in, int estimatedSize, Map<K,V> m, Type keyType, Type valueType, ParserContext ctx) throws ParseException, IOException {
		ClassMeta cm = ctx.getBeanContext().getMapClassMeta(m.getClass(), keyType, valueType);
		XmlParserContext xctx = (XmlParserContext)ctx;
		return parseIntoMap(xctx, xctx.getReader(in, estimatedSize), m, cm.getKeyType(), cm.getValueType());
	}

	@Override /* ReaderParser */
	protected <E> Collection<E> doParseIntoCollection(Reader in, int estimatedSize, Collection<E> c, Type elementType, ParserContext ctx) throws ParseException, IOException {
		ClassMeta cm = ctx.getBeanContext().getCollectionClassMeta(c.getClass(), elementType);
		XmlParserContext xctx = (XmlParserContext)ctx;
		return parseIntoCollection(xctx, xctx.getReader(in, estimatedSize), c, cm.getElementType());
	}

	@Override /* ReaderParser */
	protected Object[] doParseArgs(Reader in, int estimatedSize, ClassMeta<?>[] argTypes, ParserContext ctx) throws ParseException, IOException {
		XmlParserContext xctx = (XmlParserContext)ctx;
		return parseArgs(xctx, xctx.getReader(in, estimatedSize), argTypes);
	}

	@Override /* CoreApi */
	public XmlParser setProperty(String property, Object value) throws LockedException {
		checkLock();
		if (! xpp.setProperty(property, value))
			super.setProperty(property, value);
		return this;
	}

	@Override /* CoreApi */
	public XmlParser setProperties(ObjectMap properties) throws LockedException {
		for (Map.Entry<String,Object> e : properties.entrySet())
			setProperty(e.getKey(), e.getValue());
		return this;
	}

	@Override /* CoreApi */
	public XmlParser addNotBeanClasses(Class<?>...classes) throws LockedException {
		super.addNotBeanClasses(classes);
		return this;
	}

	@Override /* CoreApi */
	public XmlParser addFilters(Class<?>...classes) throws LockedException {
		super.addFilters(classes);
		return this;
	}

	@Override /* CoreApi */
	public <T> XmlParser addImplClass(Class<T> interfaceClass, Class<? extends T> implClass) throws LockedException {
		super.addImplClass(interfaceClass, implClass);
		return this;
	}

	@Override /* CoreApi */
	public XmlParser setClassLoader(ClassLoader classLoader) throws LockedException {
		super.setClassLoader(classLoader);
		return this;
	}

	@Override /* Lockable */
	public XmlParser lock() {
		super.lock();
		return this;
	}

	@Override /* Lockable */
	public XmlParser clone() {
		try {
			XmlParser c = (XmlParser)super.clone();
			c.xpp = xpp.clone();
			return c;
		} catch (CloneNotSupportedException e) {
			throw new RuntimeException(e); // Shouldn't happen.
		}
	}
}
