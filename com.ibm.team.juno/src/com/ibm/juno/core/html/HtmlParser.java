/*******************************************************************************
 * Licensed Materials - Property of IBM
 * (c) Copyright IBM Corporation 2014, 2015. All Rights Reserved.
 *
 *  The source code for this program is not published or otherwise
 *  divested of its trade secrets, irrespective of what has been
 *  deposited with the U.S. Copyright Office.
 *******************************************************************************/
package com.ibm.juno.core.html;

import static com.ibm.juno.core.html.HtmlParser.Tag.*;
import static com.ibm.juno.core.utils.StringUtils.*;
import static javax.xml.stream.XMLStreamConstants.*;

import java.io.*;
import java.lang.reflect.*;
import java.util.*;

import javax.xml.namespace.*;
import javax.xml.stream.*;
import javax.xml.stream.events.*;

import com.ibm.juno.core.*;
import com.ibm.juno.core.annotation.*;
import com.ibm.juno.core.filter.*;
import com.ibm.juno.core.parser.*;

/**
 * Parses text generated by the {@link HtmlSerializer} class back into a POJO model.
 *
 *
 * <h6 class='topic'>Media types</h6>
 * <p>
 * 	Handles <code>Content-Type</code> types: <code>text/html</code>
 *
 *
 * <h6 class='topic'>Description</h6>
 * <p>
 * 	See the {@link HtmlSerializer} class for a description of the HTML generated.
 * <p>
 * 	This class is used primarily for automated testing of the {@link HtmlSerializer} class.
 *
 *
 * <h6 class='topic'>Configurable properties</h6>
 * <p>
 * 	This class has the following properties associated with it:
 * <ul>
 * 	<li>{@link ParserProperties}
 * 	<li>{@link BeanContextProperties}
 * </ul>
 *
 *
 * @author James Bognar (jbognar@us.ibm.com)
 */
@SuppressWarnings({ "rawtypes", "unchecked" })
@Consumes({"text/html","text/html+stripped"})
public final class HtmlParser extends ReaderParser {

	/** Default parser, all default settings.*/
	public static final HtmlParser DEFAULT = new HtmlParser().lock();

	/** HTML specific properties currently defined on this class */
	protected transient HtmlParserProperties hpp = new HtmlParserProperties();

	/*
	 * Reads anything starting at the current event.
	 * <p>
	 * 	Precondition:  Must be pointing at START_ELEMENT or CHARACTERS event.
	 * 	Postcondition:  Pointing at next event to be processed.
	 */
	private <T> T parseAnything(HtmlParserContext ctx, ClassMeta<T> nt, XMLEventReader r, Object outer, Object name) throws ParseException, IOException {

		try {
			BeanContext bc = ctx.getBeanContext();
			if (nt == null)
				nt = (ClassMeta<T>)object();
			PojoFilter<T,Object> filter = (PojoFilter<T,Object>)nt.getPojoFilter();
			ClassMeta<?> ft = nt.getFilteredClassMeta();

			Object o = null;

			XMLEvent event = r.nextEvent();
			while (! (event.isStartElement() || (event.isCharacters() && ! event.asCharacters().isWhiteSpace()) || event.isEndDocument()))
				event = r.nextEvent();

			if (event.isEndDocument())
				throw new XMLStreamException("Unexpected end of stream in parseAnything for type '"+nt+"'", event.getLocation());

			if (event.isCharacters()) {
				String text = parseCharacters(event, r);
				if (ft.isObject())
					o = text;
				else if (ft.isCharSequence())
					o = text;
				else if (ft.isNumber())
					o = parseNumber(text, (Class<? extends Number>)nt.getInnerClass());
				else if (ft.isChar())
					o = text.charAt(0);
				else if (ft.isBoolean())
					o = Boolean.parseBoolean(text);
				else if (ft.canCreateNewInstanceFromString(outer))
					o = ft.newInstanceFromString(outer, text);
				else
					throw new XMLStreamException("Unexpected characters '"+event.asCharacters().getData()+"' for type '"+nt+"'", event.getLocation());

			} else {
				Tag tag = Tag.forString(event.asStartElement().getName().getLocalPart(), false);
				String tableType = "object";
				String text = "";

				if (tag.isOneOf(STRING, NUMBER, BOOLEAN, BR, FF, BS, TB))
					text = parseCharacters(event, r);

				if (tag == TABLE) {
					Map<String,String> attrs = getAttributes(event);
					tableType = attrs.get("type");
					String c = attrs.get("_class");
					if (c != null)
						ft = nt = (ClassMeta<T>)bc.getClassMetaFromString(c);
				}

				boolean isValid = true;

				if (tag == NULL)
					nextTag(r, xNULL);
				else if (tag == A)
					o = parseAnchor(ctx, event, r, nt);
				else if (ft.isObject()) {
					if (tag == STRING)
						o = text;
					else if (tag == NUMBER)
						o = parseNumber(text, null);
					else if (tag == BOOLEAN)
						o = Boolean.parseBoolean(text);
					else if (tag == TABLE) {
						if (tableType.equals("object")) {
							o = parseIntoMap(ctx, r, (Map)new ObjectMap(bc), ft.getKeyType(), ft.getValueType());
						} else if (tableType.equals("array")) {
							o = parseTableIntoCollection(ctx, r, (Collection)new ObjectList(bc), ft.getElementType());
						} else
							isValid = false;
					}
					else if (tag == UL)
						o = parseIntoCollection(ctx, r, new ObjectList(bc), null);
				}
				else if (tag == STRING && ft.isCharSequence())
					o = text;
				else if (tag == STRING && ft.isChar())
					o = text.charAt(0);
				else if (tag == STRING && ft.canCreateNewInstanceFromString(outer))
					o = ft.newInstanceFromString(outer, text);
				else if (tag == NUMBER && ft.isNumber())
					o = parseNumber(text, (Class<? extends Number>)ft.getInnerClass());
				else if (tag == BOOLEAN && ft.isBoolean())
					o = Boolean.parseBoolean(text);
				else if (tag == TABLE) {
					if (tableType.equals("object")) {
						if (ft.isMap()) {
							o = parseIntoMap(ctx, r, (Map)(ft.canCreateNewInstance(outer) ? ft.newInstance(outer) : new ObjectMap(bc)), ft.getKeyType(), ft.getValueType());
						} else if (ft.canCreateNewInstanceFromObjectMap(outer)) {
							ObjectMap m = new ObjectMap(bc);
							parseIntoMap(ctx, r, m, string(), object());
							o = ft.newInstanceFromObjectMap(outer, m);
						} else if (ft.canCreateNewBean(outer)) {
							BeanMap m = bc.newBeanMap(outer, ft.getInnerClass());
							o = parseIntoBean(ctx, r, m).getBean();
						}
						else
							isValid = false;
					} else if (tableType.equals("array")) {
						if (ft.isCollection())
							o = parseTableIntoCollection(ctx, r, (Collection)(ft.canCreateNewInstance(outer) ? ft.newInstance(outer) : new ObjectList(bc)), ft.getElementType());
						else if (ft.isArray())
							o = bc.toArray(ft, parseTableIntoCollection(ctx, r, new ArrayList(), ft.getElementType()));
						else
							isValid = false;
					} else
						isValid = false;
				} else if (tag == UL) {
					if (ft.isCollection())
						o = parseIntoCollection(ctx, r, (Collection)(ft.canCreateNewInstance(outer) ? ft.newInstance(outer) : new ObjectList(bc)), ft.getElementType());
					else if (ft.isArray())
						o = bc.toArray(ft, parseIntoCollection(ctx, r, new ArrayList(), ft.getElementType()));
					else
						isValid = false;
				} else
					isValid = false;

				if (! isValid)
					throw new XMLStreamException("Unexpected tag '"+tag+"' for type '"+nt+"'", event.getLocation());
			}


			if (filter != null && o != null)
				o = filter.unfilter(o, nt);

			if (outer != null)
				setParent(nt, o, outer);

			if (name != null)
				setName(nt, o, name);

			return (T)o;

		} catch (ParseException e) {
			throw e;
		} catch (IOException e) {
			throw e;
		} catch (RuntimeException e) {
			throw e;
		} catch (Exception e) {
			throw new ParseException(e);
		}
	}

	/*
	 * Reads an anchor tag and converts it into a bean.
	 */
	private <T> T parseAnchor(HtmlParserContext ctx, XMLEvent e, XMLEventReader r, ClassMeta<T> beanType) throws XMLStreamException {
		BeanContext bc = ctx.getBeanContext();
		String href = e.asStartElement().getAttributeByName(new QName("href")).getValue();
		String name = parseCharacters(e, r);
		Class<T> beanClass = beanType.getInnerClass();
		if (beanClass.isAnnotationPresent(HtmlLink.class)) {
			HtmlLink h = beanClass.getAnnotation(HtmlLink.class);
			BeanMap<T> m = bc.newBeanMap(beanClass);
			m.put(h.hrefProperty(), href);
			m.put(h.nameProperty(), name);
			return m.getBean();
		}
		return bc.convertToType(href, beanType);
	}

	private Map<String,String> getAttributes(XMLEvent e) {
		Map<String,String> m = new TreeMap<String,String>() ;
		for (Iterator i = e.asStartElement().getAttributes(); i.hasNext();) {
			Attribute a = (Attribute)i.next();
			m.put(a.getName().getLocalPart(), a.getValue());
		}
		return m;
	}

	/*
	 * Reads contents of <table> element.
	 * Precondition:  Must be pointing at <table> event.
	 * Postcondition:  Pointing at next START_ELEMENT or END_DOCUMENT event.
	 */
	private <K,V> Map<K,V> parseIntoMap(HtmlParserContext ctx, XMLEventReader r, Map<K,V> m, ClassMeta<K> keyType, ClassMeta<V> valueType) throws ParseException, IOException {
		try {
			Tag tag = nextTag(r, TR);

			// Skip over the column headers.
			nextTag(r, TH);
			parseElementText(r, xTH);
			nextTag(r, TH);
			parseElementText(r, xTH);
			nextTag(r, xTR);

			while (true) {
				tag = nextTag(r, TR, xTABLE);
				if (tag == xTABLE)
					break;
				nextTag(r, TD);
				K key = parseAnything(ctx, keyType, r, m, null);
				nextTag(r, xTD);
				nextTag(r, TD);
				m.put(key, parseAnything(ctx, valueType, r, m, key));
				nextTag(r, xTD);
				nextTag(r, xTR);
			}

			return m;
		} catch (XMLStreamException e) {
			throw new ParseException(e);
		}
	}

	/*
	 * Reads contents of <ul> element.
	 * Precondition:  Must be pointing at event following <ul> event.
	 * Postcondition:  Pointing at next START_ELEMENT or END_DOCUMENT event.
	 */
	private <E> Collection<E> parseIntoCollection(HtmlParserContext ctx, XMLEventReader r, Collection<E> l, ClassMeta<E> elementType) throws ParseException, IOException {
		try {
			while (true) {
				Tag tag = nextTag(r, LI, xUL);
				if (tag == xUL)
					break;
				l.add(parseAnything(ctx, elementType, r, l, null));
				nextTag(r, xLI);
			}
			return l;
		} catch (XMLStreamException e) {
			throw new ParseException(e);
		}
	}

	/*
	 * Reads contents of <ul> element into an Object array.
	 * Precondition:  Must be pointing at event following <ul> event.
	 * Postcondition:  Pointing at next START_ELEMENT or END_DOCUMENT event.
	 */
	private Object[] parseArgs(HtmlParserContext ctx, XMLEventReader r, ClassMeta<?>[] argTypes) throws ParseException, IOException {
		try {
			Object[] o = new Object[argTypes.length];
			int i = 0;
			while (true) {
				Tag tag = nextTag(r, LI, xUL);
				if (tag == xUL)
					break;
				o[i] = parseAnything(ctx, argTypes[i], r, ctx.getOuter(), null);
				i++;
				nextTag(r, xLI);
			}
			return o;
		} catch (XMLStreamException e) {
			throw new ParseException(e);
		}
	}

	/*
	 * Reads contents of <ul> element.
	 * Precondition:  Must be pointing at event following <ul> event.
	 * Postcondition:  Pointing at next START_ELEMENT or END_DOCUMENT event.
	 */
	private <E> Collection<E> parseTableIntoCollection(HtmlParserContext ctx, XMLEventReader r, Collection<E> l, ClassMeta<E> elementType) throws Exception {

		BeanContext bc = ctx.getBeanContext();
		if (elementType == null)
			elementType = (ClassMeta<E>)object();

		Tag tag = nextTag(r, TR);
		List<String> keys = new ArrayList<String>();
		while (true) {
			tag = nextTag(r, TH, xTR);
			if (tag == xTR)
				break;
			keys.add(parseElementText(r, xTH));
		}

		while (true) {
			XMLEvent event = r.nextTag();
			tag = Tag.forEvent(event);
			if (tag == xTABLE)
				break;
			if (elementType.canCreateNewBean(l)) {
				BeanMap m = bc.newBeanMap(l, elementType.getInnerClass());
				for (int i = 0; i < keys.size(); i++) {
					tag = nextTag(r, TD, NULL);
					if (tag == NULL) {
						m = null;
						nextTag(r, xNULL);
						break;
					}
					String key = keys.get(i);
					BeanMapEntry e = m.getProperty(key);
					if (e == null) {
						//onUnknownProperty(key, m, -1, -1);
						parseAnything(ctx, object(), r, l, null);
					} else {
						e.getMeta().set(m, parseAnything(ctx, e.getMeta().getClassMeta(), r, m.getBean(false), key));
					}
					nextTag(r, xTD);
				}
				l.add(m == null ? null : (E)m.getBean());
			} else {
				String c = getAttributes(event).get("_class");
				Map m = (Map)(elementType.isMap() && elementType.canCreateNewInstance(l) ? elementType.newInstance(l) : new ObjectMap(bc));
				for (int i = 0; i < keys.size(); i++) {
					tag = nextTag(r, TD, NULL);
					if (tag == NULL) {
						m = null;
						nextTag(r, xNULL);
						break;
					}
					String key = keys.get(i);
					if (m != null)
						m.put(key, parseAnything(ctx, elementType.getElementType(), r, l, key));
					nextTag(r, xTD);
				}
				if (m != null && c != null) {
					ObjectMap m2 = (m instanceof ObjectMap ? (ObjectMap)m : new ObjectMap(m).setBeanContext(ctx.getBeanContext()));
					m2.put("_class", c);
					l.add((E)m2.cast());
				} else {
					l.add((E)m);
				}
			}
			nextTag(r, xTR);
		}
		return l;
	}

	/*
	 * Reads contents of <table> element.
	 * Precondition:  Must be pointing at event following <table> event.
	 * Postcondition:  Pointing at next START_ELEMENT or END_DOCUMENT event.
	 */
	private <T> BeanMap<T> parseIntoBean(HtmlParserContext ctx, XMLEventReader r, BeanMap<T> m) throws Exception {
		Tag tag = nextTag(r, TR);

		// Skip over the column headers.
		nextTag(r, TH);
		parseElementText(r, xTH);
		nextTag(r, TH);
		parseElementText(r, xTH);
		nextTag(r, xTR);

		while (true) {
			tag = nextTag(r, TR, xTABLE);
			if (tag == xTABLE)
				break;
			nextTag(r, TD);
			String key = parseElementText(r, xTD);
			nextTag(r, TD);
			BeanPropertyMeta pMeta = m.getPropertyMeta(key);
			if (pMeta == null) {
				if (m.getMeta().isSubTyped()) {
					m.put(key, parseAnything(ctx, object(), r, m.getBean(false), key));
				} else {
					onUnknownProperty(ctx, key, m, -1, -1);
					parseAnything(ctx, object(), r, null, null);
				}
			} else {
				pMeta.set(m, parseAnything(ctx, pMeta.getClassMeta(), r, m.getBean(false), key));
			}
			nextTag(r, xTD);
			nextTag(r, xTR);
		}
		return m;
	}

	/*
	 * Parse until the next event is an end tag.
	 */
	private String parseCharacters(XMLEvent e, XMLEventReader r) throws XMLStreamException {

		List<String> strings = new LinkedList<String>();

		while (true) {
			int eventType = e.getEventType();
			if (eventType == CHARACTERS) {
				Characters c = e.asCharacters();
				if (! c.isWhiteSpace())
					strings.add(c.getData());
			}
			else if (eventType == START_ELEMENT) {
				Tag tag = Tag.forEvent(e);
				if (tag == BR)
					strings.add("\n");
				else if (tag == FF)
					strings.add("\f");
				else if (tag == BS)
					strings.add("\b");
				else if (tag == TB)
					strings.add("\t");
			}
			// Ignore all other elements.

			XMLEvent eNext = r.peek();

			if (eNext.isStartElement() || eNext.isEndElement()) {
				Tag tag = Tag.forEvent(eNext);
				if (! (tag.isOneOf(A, xA, BR, xBR, FF, xFF, BS, xBS, TB, xTB, STRING, xSTRING, NUMBER, xNUMBER, BOOLEAN, xBOOLEAN)))
					return trim(join(strings));
			} else if (eNext.isEndDocument()) {
				return trim(join(strings));
			}

			e = r.nextEvent();
		}
	}

	private String trim(String s) {
		int i2 = 0, i3;
		for (i2 = 0; i2 < s.length(); i2++) {
			char c = s.charAt(i2);
			if (c != ' ')
				break;
		}
		for (i3 = s.length(); i3 > i2; i3--) {
			char c = s.charAt(i3-1);
			if (c != ' ')
				break;
		}
		return s.substring(i2, i3);
	}

	/*
	 * Reads the element text of the current element, accounting for <a> and <br> tags. <br>
	 * Precondition:  Must be pointing at first event AFTER the start tag.
	 * Postcondition:  Pointing at next START_ELEMENT or END_DOCUMENT event.
	 */
	private String parseElementText(XMLEventReader r, Tag endTag) throws XMLStreamException {

		List<String> strings = new LinkedList<String>();

		XMLEvent e = r.nextEvent();
		Tag nTag = (e.isEndElement() ? Tag.forEvent(e) : null);

		while (nTag != endTag) {
			if (e.isCharacters())
				strings.add(parseCharacters(e, r));
			e = r.nextEvent();

			if (e.getEventType() == END_ELEMENT)
				nTag = Tag.forEvent(e);

			if (nTag == endTag)
				return join(strings);
		}

		return "";
	}

	enum Tag {

		TABLE(1,"<table>"),
		TR(2,"<tr>"),
		TH(3,"<th>"),
		TD(4,"<td>"),
		UL(5,"<ul>"),
		LI(6,"<li>"),
		STRING(7,"<string>"),
		NUMBER(8,"<number>"),
		BOOLEAN(9,"<boolean>"),
		NULL(10,"<null>"),
		A(11,"<a>"),
		BR(12,"<br>"),		// newline
		FF(13,"<ff>"),		// formfeed
		BS(14,"<bs>"),		// backspace
		TB(15,"<tb>"),		// tab
		xTABLE(-1,"</table>"),
		xTR(-2,"</tr>"),
		xTH(-3,"</th>"),
		xTD(-4,"</td>"),
		xUL(-5,"</ul>"),
		xLI(-6,"</li>"),
		xSTRING(-7,"</string>"),
		xNUMBER(-8,"</number>"),
		xBOOLEAN(-9,"</boolean>"),
		xNULL(-10,"</null>"),
		xA(-11,"</a>"),
		xBR(-12,"</br>"),
		xFF(-13,"</ff>"),
		xBS(-14,"</bs>"),
		xTB(-15,"</tb>");

		private Map<Integer,Tag> cache = new HashMap<Integer,Tag>();

		int id;
		String label;

		Tag(int id, String label) {
			this.id = id;
			this.label = label;
			cache.put(id, this);
		}

		static Tag forEvent(XMLEvent event) throws XMLStreamException {
			if (event.isStartElement())
				return forString(event.asStartElement().getName().getLocalPart(), false);
			else if (event.isEndElement())
				return forString(event.asEndElement().getName().getLocalPart(), true);
			throw new XMLStreamException("Invalid call to Tag.forEvent on event of type ["+event.getEventType()+"]");
		}

		private static Tag forString(String tag, boolean end) throws XMLStreamException {
			char c = tag.charAt(0);
			Tag t = null;
			if (c == 'u')
				t = (end ? xUL : UL);
			else if (c == 'l')
				t = (end ? xLI : LI);
			else if (c == 's')
				t = (end ? xSTRING : STRING);
			else if (c == 'b') {
				c = tag.charAt(1);
				if (c == 'o')
					t = (end ? xBOOLEAN : BOOLEAN);
				else if (c == 'r')
					t = (end ? xBR : BR);
				else if (c == 's')
					t = (end ? xBS : BS);
			}
			else if (c == 'a')
				t = (end ? xA : A);
			else if (c == 'n') {
				c = tag.charAt(2);
				if (c == 'm')
					t = (end ? xNUMBER : NUMBER);
				else if (c == 'l')
					t = (end ? xNULL : NULL);
			}
			else if (c == 't') {
				c = tag.charAt(1);
				if (c == 'a')
					t = (end ? xTABLE : TABLE);
				else if (c == 'r')
					t = (end ? xTR : TR);
				else if (c == 'h')
					t = (end ? xTH : TH);
				else if (c == 'd')
					t = (end ? xTD : TD);
				else if (c == 'b')
					t = (end ? xTB : TB);
			}
			else if (c == 'f')
				t = (end ? xFF : FF);
			if (t == null)
				throw new XMLStreamException("Unknown tag '"+tag+"' encountered");
			return t;
		}

		@Override /* Object */
		public String toString() {
			return label;
		}

		public boolean isOneOf(Tag...tags) {
			for (Tag tag : tags)
				if (tag == this)
					return true;
			return false;
		}
	}

	/*
	 * Reads the current tag.  Advances past anything that's not a start or end tag.  Throws an exception if
	 * 	it's not one of the expected tags.
	 * Precondition:  Must be pointing before the event we want to parse.
	 * Postcondition:  Pointing at the tag just parsed.
	 */
	private Tag nextTag(XMLEventReader r, Tag...expected) throws XMLStreamException {
		XMLEvent event = r.nextTag();
		Tag tag = Tag.forEvent(event);
		if (expected.length == 0)
			return tag;
		for (Tag t : expected)
			if (t == tag)
				return tag;
		throw new XMLStreamException("Unexpected tag: " + tag, event.getLocation());
	}

	private String join(List<String> s) {
		if (s.size() == 0)
			return "";
		if (s.size() == 1)
			return s.get(0);
		StringBuilder sb = new StringBuilder();
		for (String ss : s)
			sb.append(ss);
		return sb.toString();
	}

	//--------------------------------------------------------------------------------
	// Overridden methods
	//--------------------------------------------------------------------------------

	@Override /* Parser */
	public HtmlParserContext createContext(ObjectMap properties, Method javaMethod, Object outer) {
		return new HtmlParserContext(getBeanContext(), pp, hpp, properties, javaMethod, outer);
	}

	@Override /* Parser */
	protected <T> T doParse(Reader in, int estimatedSize, ClassMeta<T> type, ParserContext ctx) throws ParseException, IOException {
		type = ctx.getBeanContext().normalizeClassMeta(type);
		HtmlParserContext ctx2 = (HtmlParserContext)ctx;
		return parseAnything(ctx2, type, ctx2.getReader(in, estimatedSize), ctx.getOuter(), null);
	}

	@Override /* ReaderParser */
	protected <K,V> Map<K,V> doParseIntoMap(Reader in, int estimatedSize, Map<K,V> m, Type keyType, Type valueType, ParserContext ctx) throws ParseException, IOException {
		HtmlParserContext hctx = (HtmlParserContext)ctx;
		return parseIntoMap(hctx, hctx.getReader(in, estimatedSize), m, ctx.getBeanContext().getClassMeta(keyType), ctx.getBeanContext().getClassMeta(valueType));
	}

	@Override /* ReaderParser */
	protected <E> Collection<E> doParseIntoCollection(Reader in, int estimatedSize, Collection<E> c, Type elementType, ParserContext ctx) throws ParseException, IOException {
		HtmlParserContext hctx = (HtmlParserContext)ctx;
		return parseIntoCollection(hctx, hctx.getReader(in, estimatedSize), c, ctx.getBeanContext().getClassMeta(elementType));
	}

	@Override /* ReaderParser */
	protected Object[] doParseArgs(Reader in, int estimatedSize, ClassMeta<?>[] argTypes, ParserContext ctx) throws ParseException, IOException {
		HtmlParserContext hctx = (HtmlParserContext)ctx;
		return parseArgs(hctx, hctx.getReader(in, estimatedSize), argTypes);
	}

	@Override /* CoreApi */
	public HtmlParser setProperty(String property, Object value) throws LockedException {
		checkLock();
		if (! hpp.setProperty(property, value))
			super.setProperty(property, value);
		return this;
	}

	@Override /* CoreApi */
	public HtmlParser setProperties(ObjectMap properties) throws LockedException {
		for (Map.Entry<String,Object> e : properties.entrySet())
			setProperty(e.getKey(), e.getValue());
		return this;
	}

	@Override /* CoreApi */
	public HtmlParser addNotBeanClasses(Class<?>...classes) throws LockedException {
		super.addNotBeanClasses(classes);
		return this;
	}

	@Override /* CoreApi */
	public HtmlParser addFilters(Class<?>...classes) throws LockedException {
		super.addFilters(classes);
		return this;
	}

	@Override /* CoreApi */
	public <T> HtmlParser addImplClass(Class<T> interfaceClass, Class<? extends T> implClass) throws LockedException {
		super.addImplClass(interfaceClass, implClass);
		return this;
	}

	@Override /* CoreApi */
	public HtmlParser setClassLoader(ClassLoader classLoader) throws LockedException {
		super.setClassLoader(classLoader);
		return this;
	}

	@Override /* Lockable */
	public HtmlParser lock() {
		super.lock();
		return this;
	}

	@Override /* Lockable */
	public HtmlParser clone() {
		try {
			return (HtmlParser)super.clone();
		} catch (CloneNotSupportedException e) {
			throw new RuntimeException(e); // Shouldn't happen
		}
	}
}
