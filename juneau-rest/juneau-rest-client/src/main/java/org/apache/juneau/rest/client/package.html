<!DOCTYPE HTML>
<!--
/***************************************************************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 *
 ***************************************************************************************************************************/
 -->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<style type="text/css">
		/* For viewing in Page Designer */
		@IMPORT url("../../../../../javadoc.css");

		/* For viewing in REST interface */
		@IMPORT url("../htdocs/javadoc.css");
		body { 
			margin: 20px; 
		}	
	</style>
	<script>
		/* Replace all @code and @link tags. */	
		window.onload = function() {
			document.body.innerHTML = document.body.innerHTML.replace(/\{\@code ([^\}]+)\}/g, '<code>$1</code>');
			document.body.innerHTML = document.body.innerHTML.replace(/\{\@link (([^\}]+)\.)?([^\.\}]+)\}/g, '<code>$3</code>');
		}
	</script>
</head>
<body>
<p>REST Client API</p>

<script>
	function toggle(x) {
		var div = x.nextSibling;
		while (div != null && div.nodeType != 1)
			div = div.nextSibling;
		if (div != null) {
			var d = div.style.display;
			if (d == 'block' || d == '') {
				div.style.display = 'none';
				x.className += " closed";
			} else {
				div.style.display = 'block';
				x.className = x.className.replace(/(?:^|\s)closed(?!\S)/g , '' );
			}
		}
	}
</script>

<a id='TOC'></a><h5 class='toc'>Table of Contents</h5>
<ol class='toc'>
	<li><p><a class='doclink' href='#RestClient'>REST Client API</a></p>
	<ol>
		<li><p><a class='doclink' href='#SSL'>SSL Support</a></p>
		<ol>
			<li><p><a class='doclink' href='#SSLOpts'>SSLOpts Bean</a></p>
		</ol>
		<li><p><a class='doclink' href='#Authentication'>Authentication</a></p>
		<ol>
			<li><p><a class='doclink' href='#BASIC'>BASIC Authentication</a></p>
			<li><p><a class='doclink' href='#FORM'>FORM-based Authentication</a></p>
			<li><p><a class='doclink' href='#OIDC'>OIDC Authentication</a></p>
		</ol>
		<li><p><a class='doclink' href='#ResponsePatterns'>Using Response Patterns</a></p>
		<li><p><a class='doclink' href='#PipingOutput'>Piping Response Output</a></p>
		<li><p><a class='doclink' href='#Debugging'>Debugging</a></p>
		<li><p><a class='doclink' href='#Logging'>Logging</a></p>
		<li><p><a class='doclink' href='#Interceptors'>Interceptors</a></p>
		<li><p><a class='doclink' href='#Remoteable'>Remoteable Proxies</a></p>
		<li><p><a class='doclink' href='#Other'>Other Useful Methods</a></p>
	</ol>
</ol>

<!-- ======================================================================================================== -->
<a id="RestClient"></a>
<h2 class='topic' onclick='toggle(this)'>1 - REST Client API</h2>
<div class='topic'>
	<p>
		Juneau provides an HTTP client API that makes it extremely simple to connect to remote REST interfaces and 
		seemlessly send and receive serialized POJOs in requests and responses.  
	</p>
	
	<h6 class='notes'>Features:</h6>
	<ul class='notes'>
		<li>
			Converts POJOs directly to HTTP request message bodies using {@link org.apache.juneau.serializer.Serializer} 
			classes.
	 	<li>
	 		Converts HTTP response message bodies directly to POJOs using {@link org.apache.juneau.parser.Parser} 
	 		classes.
		<li>
			Exposes the full functionality of the Apache HttpClient API by exposing all methods defined on the 
			{@link org.apache.http.impl.client.HttpClientBuilder} class.
		<li>
			Provides various convenience methods for setting up common SSL and authentication methods.
		<li>
			Provides a fluent interface that allows you to make complex REST calls in a single line of code.
	</ul>	
	<p>
		The client API is designed to work as a thin layer on top of the proven Apache HttpClient API.  
		By leveraging the HttpClient library, details such as SSL certificate negotiation, proxies, encoding, etc...
		are all handled in Apache code. 
	</p>
	<p>
		The Juneau client API prereq's Apache HttpClient 4.1.2+. 
		At a minimum, the following jars are required:
	</p>
	<ul>
		<li><code>httpclient-4.5.jar</code>
		<li><code>httpcore-4.4.1.jar</code>
		<li><code>httpmime-4.5.jar</code>
	</ul>
	
	<h6 class='topic'>Example:</h6>
	<p class='bcode'>
	<jc>// Examples below use the Juneau Address Book resource example</jc>

	<jc>// Create a reusable client with JSON support</jc>
	RestClient client = RestClient.<jsm>create</jsm>().build();
	
	<jc>// GET request, ignoring output</jc>
	<jk>try</jk> {
		<jk>int</jk> rc = client.doGet(<js>"http://localhost:9080/sample/addressBook"</js>).run();
		<jc>// Succeeded!</jc>
	} <jk>catch</jk> (RestCallException e) {
		<jc>// Failed!</jc>
		System.<jsf>err</jsf>.println(
			String.<jsm>format</jsm>(<js>"status=%s, message=%s"</js>, e.getResponseStatus(), e.getResponseMessage())
		);
	}
			
	<jc>// Remaining examples ignore thrown exceptions.</jc>		
			
	<jc>// GET request, secure, ignoring output</jc>
	client.doGet(<js>"https://localhost:9443/sample/addressBook"</js>).run();
			
	<jc>// GET request, getting output as a String.  No POJO parsing is performed.
	// Note that when calling one of the getX() methods, you don't need to call connect() or disconnect(), since
	//	it's automatically called for you.</jc>
	String output = client.doGet(<js>"http://localhost:9080/sample/addressBook"</js>)
		.getResponseAsString();
			
	<jc>// GET request, getting output as a Reader</jc>
	Reader r = client.doGet(<js>"http://localhost:9080/sample/addressBook"</js>)
		.getReader();
			
	<jc>// GET request, getting output as an untyped map</jc>
	<jc>// Input must be an object (e.g. "{...}")</jc>
	ObjectMap m = client.doGet(<js>"http://localhost:9080/sample/addressBook/0"</js>)
		.getResponse(ObjectMap.<jk>class</jk>);
			
	<jc>// GET request, getting output as an untyped list</jc>
	<jc>// Input must be an array (e.g. "[...]")</jc>
	ObjectList l = client.doGet(<js>"http://localhost:9080/sample/addressBook"</js>)
		.getResponse(ObjectList.<jk>class</jk>);
			
	<jc>// GET request, getting output as a parsed bean</jc>
	<jc>// Input must be an object (e.g. "{...}")</jc>
	<jc>// Note that you don't have to do any casting!</jc>
	Person p = client.doGet(<js>"http://localhost:9080/sample/addressBook/0"</js>)
		.getResponse(Person.<jk>class</jk>);
			
	<jc>// GET request, getting output as a parsed bean</jc>
	<jc>// Input must be an array of objects (e.g. "[{...},{...}]")</jc>
	Person[] pa = client.doGet(<js>"http://localhost:9080/sample/addressBook"</js>)
		.getResponse(Person[].<jk>class</jk>);
			
	<jc>// Same as above, except as a List&lt;Person&gt;</jc>
	List&lt;Person&gt; pl = client.doGet(<js>"http://localhost:9080/sample/addressBook"</js>)
		.getResponse(List.<jk>class</jk>, Person.<jk>class</jk>);
			
	<jc>// GET request, getting output as a parsed string</jc>
	<jc>// Input must be a string (e.g. "&lt;string&gt;foo&lt;/string&gt;" or "'foo'")</jc>
	String name = client.doGet(<js>"http://localhost:9080/sample/addressBook/0/name"</js>)
		.getResponse(String.<jk>class</jk>);
			
	<jc>// GET request, getting output as a parsed number</jc>
	<jc>// Input must be a number (e.g. "&lt;number&gt;123&lt;/number&gt;" or "123")</jc>
	<jk>int</jk> age = client.doGet(<js>"http://localhost:9080/sample/addressBook/0/age"</js>)
		.getResponse(Integer.<jk>class</jk>);
			
	<jc>// GET request, getting output as a parsed boolean</jc>
	<jc>// Input must be a boolean (e.g. "&lt;boolean&gt;true&lt;/boolean&gt;" or "true")</jc>
	<jk>boolean</jk> isCurrent = client.doGet(<js>"http://localhost:9080/sample/addressBook/0/addresses/0/isCurrent"</js>)
		.getResponse(Boolean.<jk>class</jk>);
			
	<jc>// GET request, getting a filtered object</jc>
	client = RestClient.<jsm>create</jsm>().pojoSwaps(CalendarSwap.<jsf>ISO8601</jsf>.<jk>class</jk>).build();
	Calendar birthDate = client.doGet(<js>"http://localhost:9080/sample/addressBook/0/birthDate"</js>)
		.getResponse(GregorianCalendar.<jk>class</jk>);

	<jc>// PUT request on regular field</jc>
	String newName = <js>"John Smith"</js>;
	<jk>int</jk> rc = client.doPut(<js>"http://localhost:9080/addressBook/0/name"</js>, newName).run();
	
	<jc>// PUT request on filtered field</jc>
	Calendar newBirthDate = <jk>new</jk> GregorianCalendar(1, 2, 3, 4, 5, 6);
	rc = client.doPut(<js>"http://localhost:9080/sample/addressBook/0/birthDate"</js>, newBirthDate).run();
	
	<jc>// POST of a new entry to a list</jc>
	Address newAddress = <jk>new</jk> Address(<js>"101 Main St"</js>, <js>"Anywhere"</js>, <js>"NY"</js>, 12121, <jk>false</jk>);
	rc = client.doPost(<js>"http://localhost:9080/addressBook/0/addresses"</js>, newAddress).run();	
	</p>
	
	<h6 class='notes'>Notes:</h6>
	<ul class='notes'>
		<li>
			The {@link org.apache.juneau.rest.client.RestClient} class exposes all the builder methods on the Apache 
			HttpClient {@link org.apache.http.impl.client.HttpClientBuilder} class.
			Use these methods to provide any customized HTTP client behavior.
	</ul>
	
	<!-- ======================================================================================================== -->
	<a id="SSL"></a>
	<h3 class='topic' onclick='toggle(this)'>1.1 - SSL Support</h3>
	<div class='topic'>
		<p>
			The simplest way to enable SSL support in the client is to use the 
			{@link org.apache.juneau.rest.client.RestClientBuilder#enableSSL(SSLOpts)} method and one of the predefined 
			{@link org.apache.juneau.rest.client.SSLOpts} instances:
		</p>
		<ul>
			<li>{@link org.apache.juneau.rest.client.SSLOpts#DEFAULT} - Normal certificate and hostname validation.
			<li>{@link org.apache.juneau.rest.client.SSLOpts#LAX} - Allows for self-signed certificates.
		</ul>
		
		<h6 class='topic'>Example:</h6>
		<p class='bcode'>
	<jc>// Create a client that ignores self-signed or otherwise invalid certificates.</jc>
	RestClientBuilder builder = RestClient.<jsm>create</jsm>() 
		.enableSSL(SSLOpts.<jsf>LAX</jsf>);
		
	<jc>// ...or...</jc>
	RestClientBuilder builder = RestClient.<jsm>create</jsm>() 
		.enableLaxSSL();
		</p>
		<p>
			This is functionally equivalent to the following:
		</p>
		<p class='bcode'>
	RestClientBuilder builder = RestClient.<jsm>create</jsm>();
	
	HostnameVerifier hv = <jk>new</jk> NoopHostnameVerifier();
	TrustManager tm = <jk>new</jk> SimpleX509TrustManager(<jk>true</jk>);

	<jk>for</jk> (String p : <jk>new</jk> String[]{<js>"SSL"</js>,<js>"TLS"</js>,<js>"SSL_TLS"</js>}) {
		SSLContext ctx = SSLContext.<jsm>getInstance</jsm>(p);
		ctx.init(<jk>null</jk>, <jk>new</jk> TrustManager[] { tm }, <jk>null</jk>);
		SSLConnectionSocketFactory sf = <jk>new</jk> SSLConnectionSocketFactory(ctx, hv);
		builder.setSSLSocketFactory(sf);
		Registry&lt;ConnectionSocketFactory&gt; r = RegistryBuilder.&lt;ConnectionSocketFactory&gt;<jsm>.create</jsm>()
			.register(<js>"https"</js>, sf).build();
		builder.setConnectionManager(<jk>new</jk> PoolingHttpClientConnectionManager(r));
	}
		</p>
		<p>
			More complex SSL support can be enabled through the various {@link org.apache.http.impl.client.HttpClientBuilder} 
			methods defined on the class.
		</p>
		
		<!-- ======================================================================================================== -->
		<a id="SSLOpts"></a>
		<h4 class='topic' onclick='toggle(this)'>1.1.1 - SSLOpts Bean</h4>
		<div class='topic'>
			<p>
				The {@link org.apache.juneau.rest.client.SSLOpts} class itself is a bean that can be created by the 
				parsers.
				For example, SSL options can be specified in a config file and retrieved as a bean using the 
				{@link org.apache.juneau.ini.ConfigFile} class.
			</p>
			
			<h6 class='figure'>Contents of <code>MyConfig.cfg</code></h6>
			<p class='bcode'>
		<jc>#================================================================================
		# My Connection Settings
		#================================================================================</jc>
		[Connection]
		url = https://myremotehost:9443
		ssl = {certValidate:'LAX',hostVerify:'LAX'}
			</p>
			
			<h6 class='figure'>Code that reads an <code>SSLOpts</code> bean from the config file</h6>
			<p class='bcode'>
		<jc>// Read config file and set SSL options based on what's in that file.</jc>
		ConfigFile cf = ConfigFile.<jsm>create</jsm>().build(<js>"MyConfig.cfg"</js>);
		SSLOpts ssl = cf.getObject(SSLOpts.<jk>class</jk>, <js>"Connection/ssl"</js>);
		RestClient rc = <jk>new</jk> RestClient().enableSSL(ssl);
			</p>
		</div>
	</div>	

	<!-- ======================================================================================================== -->
	<a id="Authentication"></a>
	<h3 class='topic' onclick='toggle(this)'>1.2 - Authentication</h3>
	<div class='topic'>

		<!-- ======================================================================================================== -->
		<a id="BASIC"></a>
		<h4 class='topic' onclick='toggle(this)'>1.2.1 - BASIC Authentication</h4>
		<div class='topic'>
			<p>
				The {@link org.apache.juneau.rest.client.RestClientBuilder#basicAuth(String,int,String,String)} method 
				can be used to quickly enable BASIC authentication support.
			</p>
			
			<h6 class='topic'>Example:</h6>
			<p class='bcode'>
	<jc>// Create a client that performs BASIC authentication using the specified user/pw.</jc>
	RestClient restClient = RestClient.<jsm>create</jsm>() 
		.basicAuth(<jsf>HOST</jsf>, <jsf>PORT</jsf>, <jsf>USER</jsf>, <jsf>PW</jsf>)
		.build();
			</p>
			<p>
				This is functionally equivalent to the following:
			</p>
			<p class='bcode'>
	RestClientBuilder builder = RestClient.<jsm>create</jsm>();
	AuthScope scope = <jk>new</jk> AuthScope(<jsf>HOST</jsf>, <jsf>PORT</jsf>);
	Credentials up = <jk>new</jk> UsernamePasswordCredentials(<jsf>USER</jsf>, <jsf>PW</jsf>);
	CredentialsProvider p = <jk>new</jk> BasicCredentialsProvider();
	p.setCredentials(scope, up);
	builder.setDefaultCredentialsProvider(p);
			</p>
		</div>
	
		<!-- ======================================================================================================== -->
		<a id="FORM"></a>
		<h4 class='topic' onclick='toggle(this)'>1.2.2 - FORM-based Authentication</h4>
		<div class='topic'>
			<p>
				The {@link org.apache.juneau.rest.client.RestClientBuilder} class does not itself provide FORM-based 
				authentication since there is no standard way of providing such support. 
				Typically, to perform FORM-based or other types of authentication, you'll want to create your own
				subclass of {@link org.apache.juneau.rest.client.RestClientBuilder} and override the 
				{@link org.apache.juneau.rest.client.RestClientBuilder#createHttpClient()} method to provide an 
				authenticated client.
			</p>
			<p>
				The following example shows how the <code>JazzRestClient</code> class provides FORM-based 
				authentication support.
			</p>
			<p class='bcode'>
	<jd>/**
	 * Constructor.
	 */</jd>
	<jk>public</jk> JazzRestClientBuilder(URI jazzUri, String user, String pw) <jk>throws</jk> IOException {
		...
	}

	<jd>/**
	 * Override the createHttpClient() method to return an authenticated client.
	 */</jd>
	<ja>@Override</ja> <jc>/* RestClientBuilder */</jc>
	<jk>protected</jk> CloseableHttpClient createHttpClient() <jk>throws</jk> Exception {
		CloseableHttpClient client = <jk>super</jk>.createHttpClient();
		formBasedAuthenticate(client);
		visitAuthenticatedURL(client);
		<jk>return</jk> client;
	}

	<jc>/*
	 * Performs form-based authentication against the Jazz server.
	 */</jc>
	<jk>private void</jk> formBasedAuthenticate(HttpClient client) <jk>throws</jk> IOException {

		URI uri2 = <jf>jazzUri</jf>.resolve(<js>"j_security_check"</js>);
		HttpPost request = <jk>new</jk> HttpPost(uri2);
		request.setConfig(RequestConfig.<jsm>custom</jsm>().setRedirectsEnabled(<jk>false</jk>).build());
		
		<jc>// Charset must explicitly be set to UTF-8 to handle user/pw with non-ascii characters.</jc>
		request.addHeader(<js>"Content-Type"</js>, <js>"application/x-www-form-urlencoded; charset=utf-8"</js>);

		NameValuePairs params = <jk>new</jk> NameValuePairs()
			.append(<jk>new</jk> BasicNameValuePair(<js>"j_username""</js>, <jf>user</jf>))
			.append(<jk>new</jk> BasicNameValuePair(<js>"j_password"</js>, <jf>pw</jf>));
		request.setEntity(<jk>new</jk> UrlEncodedFormEntity(params));

		HttpResponse response = client.execute(request);
		<jk>try</jk> {
			<jk>int</jk> rc = response.getStatusLine().getStatusCode();

			Header authMsg = response.getFirstHeader(<js>"X-com-ibm-team-repository-web-auth-msg"</js>);
			<jk>if</jk> (authMsg != <jk>null</jk>)
				<jk>throw new</jk> IOException(authMsg.getValue());

			<jc>// The form auth request should always respond with a 200 ok or 302 redirect code</jc>
			<jk>if</jk> (rc == <jsf>SC_MOVED_TEMPORARILY</jsf>) {
				<jk>if</jk> (response.getFirstHeader(<js>"Location"</js>).getValue().matches(<js>"^.*/auth/authfailed.*$"</js>))
					<jk>throw new</jk> IOException(<js>"Invalid credentials."</js>);
			} <jk>else if</jk> (rc != <jsf>SC_OK</jsf>) {
				<jk>throw new</jk> IOException(<js>"Unexpected HTTP status: "</js> + rc);
			}
		} <jk>finally</jk> {
			EntityUtils.<jsm>consume</jsm>(response.getEntity());
		}
	}

	<jc>/*
	 * This is needed for Tomcat because it responds with SC_BAD_REQUEST when the j_security_check URL is visited before an
	 * authenticated URL has been visited. This same URL must also be visited after authenticating with j_security_check
	 * otherwise tomcat will not consider the session authenticated
	 */</jc>
	<jk>private int</jk> visitAuthenticatedURL(HttpClient httpClient) <jk>throws</jk> IOException {
		HttpGet authenticatedURL = <jk>new</jk> HttpGet(<jf>jazzUri</jf>.resolve(<js>"authenticated/identity"</js>));
		HttpResponse response = httpClient.execute(authenticatedURL);
		<jk>try</jk> {
			<jk>return</jk> response.getStatusLine().getStatusCode();
		} <jk>finally</jk> {
			EntityUtils.<jsm>consume</jsm>(response.getEntity());
		}
	}
			</p>
		</div>
		
		<!-- ======================================================================================================== -->
		<a id="OIDC"></a>
		<h4 class='topic' onclick='toggle(this)'>1.2.3 - OIDC Authentication</h4>
		<div class='topic'>
			<p>
				The following example shows how the <code>JazzRestClient</code> class provides OIDC authentication 
				support.
			</p>
	<p class='bcode'>
	<jd>/**
	 * Constructor.
	 */</jd>
	<jk>public</jk> JazzRestClientBuilder(URI jazzUri, String user, String pw) <jk>throws</jk> IOException {
		...
	}

	<jd>/**
	 * Override the createHttpClient() method to return an authenticated client.
	 */</jd>
	<ja>@Override</ja> <jc>/* RestClientBuilder */</jc>
	<jk>protected</jk> CloseableHttpClient createHttpClient() <jk>throws</jk> Exception {
		CloseableHttpClient client = <jk>super</jk>.createHttpClient();
		oidcAuthenticate(client);
			<jk>return</jk> client;
		}

	<jk>private void</jk> oidcAuthenticate(HttpClient client) <jk>throws</jk> IOException {

		HttpGet request = <jk>new</jk> HttpGet(<jf>jazzUri</jf>);
		request.setConfig(RequestConfig.<jsm>custom</jsm>().setRedirectsEnabled(<jk>false</jk>).build());
		
		<jc>// Charset must explicitly be set to UTF-8 to handle user/pw with non-ascii characters.</jc>
		request.addHeader(<js>"Content-Type"</js>, <js>"application/x-www-form-urlencoded; charset=utf-8"</js>);

		HttpResponse response = client.execute(request);
		<jk>try</jk> {
			<jk>int</jk> code = response.getStatusLine().getStatusCode();

			<jc>// Already authenticated</jc>
			<jk>if</jk> (code == <jsf>SC_OK</jsf>)
				<jk>return</jk>;

			<jk>if</jk> (code != <jsf>SC_UNAUTHORIZED</jsf>)
				<jk>throw new</jk> RestCallException(<js>"Unexpected response during OIDC authentication: "</js> 
					+ response.getStatusLine());

			<jc>// x-jsa-authorization-redirect</jc>
			String redirectUri = getHeader(response, <js>"X-JSA-AUTHORIZATION-REDIRECT"</js>);

			<jk>if</jk> (redirectUri == <jk>null</jk>)
				<jk>throw new</jk> RestCallException(<js>"Expected a redirect URI during OIDC authentication: "</js> 
					+ response.getStatusLine());

			<jc>// Handle Bearer Challenge</jc>
			HttpGet method = <jk>new</jk> HttpGet(redirectUri + <js>"&amp;prompt=none"</js>);
			addDefaultOidcHeaders(method);

			response = client.execute(method);

			code = response.getStatusLine().getStatusCode();

			<jk>if</jk> (code != <jsf>SC_OK</jsf>)
				<jk>throw new</jk> RestCallException(<js>"Unexpected response during OIDC authentication phase 2: "</js> 
					+ response.getStatusLine());

			String loginRequired = getHeader(response, <js>"X-JSA-LOGIN-REQUIRED"</js>);

			<jk>if</jk> (! <js>"true"</js>.equals(loginRequired))
				<jk>throw new</jk> RestCallException(<js>"X-JSA-LOGIN-REQUIRED header not found on response during OIDC authentication phase 2: "</js> 
					+ response.getStatusLine());

			method = <jk>new</jk> HttpGet(redirectUri + <js>"&amp;prompt=none"</js>);

			addDefaultOidcHeaders(method);
			response = client.execute(method);

			code = response.getStatusLine().getStatusCode();

			<jk>if</jk> (code != <jsf>SC_OK</jsf>)
				<jk>throw new</jk> RestCallException(<js>"Unexpected response during OIDC authentication phase 3: "</js> 
					+ response.getStatusLine());

			<jc>// Handle JAS Challenge</jc>
			method = <jk>new</jk> HttpGet(redirectUri);
			addDefaultOidcHeaders(method);

			response = client.execute(method);

			code = response.getStatusLine().getStatusCode();

			<jk>if</jk> (code != <jsf>SC_OK</jsf>)
				<jk>throw new</jk> RestCallException(<js>"Unexpected response during OIDC authentication phase 4: "</js> 
					+ response.getStatusLine());

			<jf>cookie</jf> = getHeader(response, <js>"Set-Cookie"</js>);

			Header[] defaultHeaders = <jk>new</jk> Header[] {
				<jk>new</jk> BasicHeader(<js>"User-Agent"</js>, <js>"Jazz Native Client"</js>),
				<jk>new</jk> BasicHeader(<js>"X-com-ibm-team-configuration-versions"</js>, 
					<js>"com.ibm.team.rtc=6.0.0,com.ibm.team.jazz.foundation=6.0"</js>),
				<jk>new</jk> BasicHeader(<js>"Accept"</js>, <js>"text/json"</js>),
				<jk>new</jk> BasicHeader(<js>"Authorization"</js>, <js>"Basic "</js> 
					+ StringUtils.<jsm>base64EncodeToString</jsm>(<jf>user</jf> + <js>":"</js> + <jf>pw</jf>)),
				<jk>new</jk> BasicHeader(<js>"Cookie"</js>, cookie)
	};

			setDefaultHeaders(Arrays.<jsm>asList</jsm>(defaultHeaders));

		} <jk>finally</jk> {
			EntityUtils.<jsm>consume</jsm>(response.getEntity());
		}
	}

	<jk>private void</jk> addDefaultOidcHeaders(HttpRequestBase method) {
		method.addHeader(<js>"User-Agent"</js>, <js>"Jazz Native Client"</js>);
		method.addHeader(<js>"X-com-ibm-team-configuration-versions"</js>, 
			<js>"com.ibm.team.rtc=6.0.0,com.ibm.team.jazz.foundation=6.0"</js>);
		method.addHeader(<js>"Accept"</js>, <js>"text/json"</js>);

		<jk>if</jk> (<jf>cookie</jf> != <jk>null</jk>) {
			method.addHeader(<js>"Authorization"</js>, <js>"Basic "</js> 
				+ StringUtils.<jsm>base64EncodeToString</jsm>(<jf>user</jf> + <js>":"</js> + <jf>pw</jf>));
			method.addHeader(<js>"Cookie"</js>, cookie);
		}
	}
			</p>	
		</div>
	</div>

	<!-- ======================================================================================================== -->
	<a id="ResponsePatterns"></a>
	<h3 class='topic' onclick='toggle(this)'>1.3 - Using Response Patterns</h3>
	<div class='topic'>
		<p>
			One issue with REST (and HTTP in general) is that the HTTP response code must be set as a header before the 
			body of the request is sent.  This can be problematic when REST calls invoke long-running processes, pipes
			the results through the connection, and then fails after an HTTP 200 has already been sent.
		</p>
		<p>
			One common solution is to serialize some text at the end to indicate whether the long-running process 
			succeeded (e.g. <js>"FAILED"</js> or <js>"SUCCEEDED"</js>).
		</p>
		<p>
			The {@link org.apache.juneau.rest.client.RestClient} class has convenience methods for scanning the 
			response without interfering with the other methods used for retrieving output.  
		</p>
		<p>
			The following example shows how the {@link org.apache.juneau.rest.client.RestCall#successPattern(String)} 
			method can be used to look for a SUCCESS message in the output:
		</p>	
		
		<h6 class='topic'>Example:</h6>
		<p class='bcode'>
	<jc>// Throw a RestCallException if SUCCESS is not found in the output.</jc>
	restClient.doPost(<jsf>URL</jsf>)
		.successPattern(<js>"SUCCESS"</js>)
		.run();
		</p>
		<p>
			The {@link org.apache.juneau.rest.client.RestCall#failurePattern(String)} method does the opposite.  
			It throws an exception if a failure message is detected.
		</p>	
		
		<h6 class='topic'>Example:</h6>
		<p class='bcode'>
	<jc>// Throw a RestCallException if FAILURE or ERROR is found in the output.</jc>
	restClient.doPost(<jsf>URL</jsf>)
		.failurePattern(<js>"FAILURE|ERROR"</js>)
		.run();
		</p>
		<p>
			These convenience methods are specialized methods that use the 
			{@link org.apache.juneau.rest.client.RestCall#responsePattern(ResponsePattern)} method which uses regular 
			expression matching against the response body.
			This method can be used to search for arbitrary patterns in the response body.
		</p>
		<p>
			The following example shows how to use a response pattern finder to find and capture patterns for 
			<js>"x=number"</js> and <js>"y=string"</js> from a response body.
		</p>	
		
		<h6 class='topic'>Example:</h6>
		<p class='bcode'>
	<jk>final</jk> List&lt;Number&gt; xList = <jk>new</jk> ArrayList&lt;Number&gt;();
	<jk>final</jk> List&lt;String&gt; yList = <jk>new</jk> ArrayList&lt;String&gt;();
	
	String responseText = restClient.doGet(<jsf>URL</jsf>)
		.addResponsePattern(
			<jk>new</jk> ResponsePattern(<js>"x=(\\d+)"</js>) {
				<ja>@Override</ja>
				<jk>public void</jk> onMatch(RestCall restCall, Matcher m) <jk>throws</jk> RestCallException {
					xList.add(Integer.<jsm>parseInt</jsm>(m.group(1)));
				}
				<ja>@Override</ja>
				<jk>public void</jk> onNoMatch(RestCall restCall) <jk>throws</jk> RestCallException {
					<jk>throw new</jk> RestCallException(<js>"No X's found!"</js>);
				}
			}
		)
		.addResponsePattern(
			<jk>new</jk> ResponsePattern(<js>"y=(\\S+)"</js>) {
				<ja>@Override</ja>
				<jk>public void</jk> onMatch(RestCall restCall, Matcher m) <jk>throws</jk> RestCallException {
					yList.add(m.group(1));
				}
				<ja>@Override</ja>
				<jk>public void</jk> onNoMatch(RestCall restCall) <jk>throws</jk> RestCallException {
					<jk>throw new</jk> RestCallException(<js>"No Y's found!"</js>);
				}
			}
		)
		.getResponseAsString();
		</p>
		<p>
			Using response patterns does not affect the functionality of any of the other methods
			used to retrieve the response such as {@link org.apache.juneau.rest.client.RestCall#getResponseAsString()} 
			or {@link org.apache.juneau.rest.client.RestCall#getResponse(Class)}.<br>
			HOWEVER, if you want to retrieve the entire text of the response from inside the match methods,
			use {@link org.apache.juneau.rest.client.RestCall#getCapturedResponse()} since this method will not absorb 
			the response for those other methods.
		</p>
	</div>
	
	<!-- ======================================================================================================== -->
	<a id="#PipingOutput"></a>
	<h3 class='topic' onclick='toggle(this)'>1.4 - Piping Response Output</h3>
	<div class='topic'>
		<p>
			The {@link org.apache.juneau.rest.client.RestCall} class provides various convenience <code>pipeTo()</code> 
			methods to pipe output to output streams and writers.
		</p>
		<p>
			If you want to pipe output without any intermediate buffering, you can use the 
			{@link org.apache.juneau.rest.client.RestCall#byLines()} method.  
			This will cause the output to be piped and flushed after every line.  
			This can be useful if you want to display the results in real-time from a long running process producing
			output on a REST call.
		</p>
		
		<h6 class='topic'>Example:</h6>
		<p class='bcode'>
	<jc>// Pipe output from REST call to System.out in real-time.</jc>
	restClient.doPost(<jsf>URL</jsf>).byLines().pipeTo(<jk>new</jk> PrintWriter(System.<jk>out</jk>)).run();
		</p>
	</div>	
	
	<!-- ======================================================================================================== -->
	<a id="Debugging"></a>
	<h3 class='topic' onclick='toggle(this)'>1.5 - Debugging</h3>
	<div class='topic'>
		<p>
			Use the {@link org.apache.juneau.rest.client.RestClientBuilder#debug()} method to enable logging for HTTP requests
			made from the client.
		</p>
		<p>
			Under-the-covers, this is simply a shortcut for adding the {@link org.apache.juneau.rest.client.RestCallLogger#DEFAULT} 
			interceptor to the client.  
			This causes the following output to be generated by the Java <code>org.apache.juneau.rest.client</code> 
			logger at <jsf>WARNING</jsf> level:
		</p>
		<p class='bcode'>
	=== HTTP Call (outgoing) =======================================================
	=== REQUEST ===
	POST http://localhost:10000/testUrl HTTP/1.1
	---request headers---
		Debug: true
		No-Trace: true
		Accept: application/json
	---request entity---
		Content-Type: application/json
	---request content---
	{"foo":"bar","baz":123}
	=== RESPONSE ===
	HTTP/1.1 200 OK
	---response headers---
		Content-Type: application/json;charset=utf-8
		Content-Length: 21
		Server: Jetty(8.1.0.v20120127)
	---response content---
	{"message":"OK then"}
	=== END ========================================================================
		</p>
		<p>
			This setting also causes a <code>Debug: true</code> header value to trigger logging of the request on the 
			server side as well.
		</p>
		<p class='bcode'>
	=== HTTP Request (incoming) ====================================================
	HTTP POST /testUrl
	---Headers---
		Host: localhost:10000
		Transfer-Encoding: chunked
		Accept: application/json
		Content-Type: application/json
		User-Agent: Apache-HttpClient/4.5 (Java/1.6.0_65)
		Connection: keep-alive
		Debug: true
		Accept-Encoding: gzip,deflate
	---Default Servlet Headers---
	---Body---
	{"foo":"bar","baz":123}
	=== END ========================================================================
		</p>
	</div>
	
	<!-- ======================================================================================================== -->
	<a id="Logging"></a>
	<h3 class='topic' onclick='toggle(this)'>1.6 - Logging</h3>
	<div class='topic'>
		<p>
			Use the {@link org.apache.juneau.rest.client.RestClientBuilder#logTo(Level,Logger)} and 
			{@link org.apache.juneau.rest.client.RestCall#logTo(Level,Logger)} methods to log HTTP calls.
			These methods will cause the HTTP request and response headers and body to be logged to the specified logger.  
		</p>
		
		<h6 class='topic'>Example:</h6>
		<p class='bcode'>
	<jc>// Log the HTTP request/response to the specified logger.</jc>
	<jk>int</jk> rc = restClient.doGet(<jsf>URL</jsf>).logTo(<jsf>INFO</jsf>, getLogger()).run();
		</p>
		<p>
			The method call is ignored if the logger level is below the specified level.
		</p>
		<p>
			Customized logging can be handled by sub-classing the {@link org.apache.juneau.rest.client.RestCallLogger} 
			class and using the  {@link org.apache.juneau.rest.client.RestCall#interceptor(RestCallInterceptor)} method.
		</p>
	</div>
	
	<!-- ======================================================================================================== -->
	<a id="Interceptors"></a>
	<h3 class='topic' onclick='toggle(this)'>1.7 - Interceptors</h3>
	<div class='topic'>
		<p>
			The {@link org.apache.juneau.rest.client.RestClientBuilder#interceptors(RestCallInterceptor...)} and 
			{@link org.apache.juneau.rest.client.RestCall#interceptor(RestCallInterceptor)} methods can be used to 
			intercept responses during specific connection lifecycle events.
		</p>
		<p>
			The {@link org.apache.juneau.rest.client.RestCallLogger} class is an example of an interceptor that uses 
			the various lifecycle methods to log HTTP requests.
		</p>
		<p class='bcode'>
	<jd>/**
	 * Specialized interceptor for logging calls to a log file.
	 */</jd>
	<jk>public class</jk> RestCallLogger <jk>extends</jk> RestCallInterceptor {
	
		<jk>private</jk> Level <jf>level</jf>;
		<jk>private</jk> Logger <jf>log</jf>;
	
		<jd>/**
		 * Constructor.
		 *
		 * <ja>@param</ja> level The log level to log messages at.
		 * <ja>@param</ja> log The logger to log to.
		 */</jd>
		<jk>protected</jk> RestCallLogger(Level level, Logger log) {
			<jk>this</jk>.<jf>level</jf> = level;
			<jk>this</jk>.<jf>log</jf> = log;
		}
	
		<ja>@Override</ja> <jc>/* RestCallInterceptor */</jc>
		<jk>public void</jk> onInit(RestCall restCall) {
			<jk>if</jk> (<jf>log</jf>.isLoggable(<jf>level</jf>))
				restCall.captureResponse();
		}
	
		<ja>@Override</ja> <jc>/* RestCallInterceptor */</jc>
		<jk>public void</jk> onConnect(RestCall restCall, <jk>int</jk> statusCode, HttpRequest req, HttpResponse res) {
			<jc>// Do nothing.</jc>
		}
	
		<ja>@Override</ja> <jc>/* RestCallInterceptor */</jc>
		<jk>public void</jk> onRetry(RestCall restCall, <jk>int</jk> statusCode, HttpRequest req, HttpResponse res) {
			<jk>if</jk> (<jf>log</jf>.isLoggable(<jf>level</jf>))
				<jf>log</jf>.log(level, MessageFormat.<jsm>format</jsm>(<js>"Call to {0} returned {1}.  Will retry."</js>, req.getRequestLine().getUri(), statusCode)); 
		}
	
		<ja>@Override</ja> <jc>/* RestCallInterceptor */</jc>
		<jk>public void</jk> onClose(RestCall restCall) <jk>throws</jk> RestCallException {
			<jk>try</jk> {
				<jk>if</jk> (<jf>log</jf>.isLoggable(<jf>level</jf>)) {
					String output = restCall.getCapturedResponse();
					StringBuilder sb = <jk>new</jk> StringBuilder();
					HttpUriRequest req = restCall.getRequest();
					HttpResponse res = restCall.getResponse();
					<jk>if</jk> (req != <jk>null</jk>) {
						sb.append(<js>"\n=== HTTP Call (outgoing) ========================================================="</js>);
	
						sb.append(<js>"\n=== REQUEST ===\n"</js>).append(req);
						sb.append(<js>"\n---request headers---"</js>);
						<jk>for</jk> (Header h : req.getAllHeaders())
							sb.append(<js>"\n"</js>).append(h);
						<jk>if</jk> (req <jk>instanceof</jk> HttpEntityEnclosingRequestBase) {
							sb.append(<js>"\n---request entity---"</js>);
							HttpEntityEnclosingRequestBase req2 = (HttpEntityEnclosingRequestBase)req;
							HttpEntity e = req2.getEntity();
							<jk>if</jk> (e == <jk>null</jk>)
								sb.append(<js>"\nEntity is null"</js>);
							<jk>else</jk> {
								<jk>if</jk> (e.getContentType() != <jk>null</jk>)
									sb.append(<js>"\n"</js>).append(e.getContentType());
								<jk>if</jk> (e.getContentEncoding() != <jk>null</jk>)
									sb.append(<js>"\n"</js>).append(e.getContentEncoding());
								<jk>if</jk> (e.isRepeatable()) {
									<jk>try</jk> {
										sb.append(<js>"\n---request content---\n"</js>).append(EntityUtils.<jsm>toString</jsm>(e));
									} <jk>catch</jk> (Exception ex) {
										<jk>throw new</jk> RuntimeException(ex);
									}
								}
							}
						}
					}
					<jk>if</jk> (res != <jk>null</jk>) {
						sb.append(<js>"\n=== RESPONSE ===\n"</js>).append(res.getStatusLine());
						sb.append(<js>"\n---response headers---"</js>);
						<jk>for</jk> (Header h : res.getAllHeaders())
							sb.append(<js>"\n"</js>).append(h);
						sb.append(<js>"\n---response content---\n"</js>).append(output);
						sb.append(<js>"\n=== END ========================================================================"</js>);
					}
					<jf>log</jf>.log(<jf>level</jf>, sb.toString());
				}
			} <jk>catch</jk> (IOException e) {
				<jf>log</jf>.log(Level.<jsf>SEVERE</jsf>, e.getLocalizedMessage(), e);
			}
		}
	}
		</p>
	</div>

	<!-- ======================================================================================================== -->
	<a id="Remoteable"></a>
	<h3 class='topic' onclick='toggle(this)'>1.8 - Remoteable Proxies</h3>
	<div class='topic'>
		<p>
			Juneau provides the capability of calling methods on POJOs on a server through client-side proxy interfaces.
			It offers a number of advantages over other similar remote proxy interfaces, such as being much simpler to 
			use and allowing much more flexibility.
		</p>
		<p>
			Proxy interfaces are retrieved using the {@link org.apache.juneau.rest.client.RestClient#getRemoteableProxy(Class)} 
			method.
			The remoteable servlet is a specialized subclass of {@link org.apache.juneau.rest.RestServlet} that 
			provides a full-blown REST interface for calling interfaces remotely. 
		</p>
		<p>
			In this example, we have the following interface defined that we want to call from the client side against
			a POJO on the server side (i.e. a Remoteable Service)...
		</p>
		<p class='bcode'>
	<jk>public interface</jk> IAddressBook {
		Person createPerson(CreatePerson cp) <jk>throws</jk> Exception;
	}
		</p>			
		<p>
			The client side code for invoking this method is shown below...
		</p>
		<p class='bcode'>
	<jc>// Create a RestClient using JSON for serialization, and point to the server-side remoteable servlet.</jc>
	RestClient client = RestClient.<jsm>create</jsm>()
		.rootUrl(<js>"https://localhost:9080/juneau/sample/remoteable"</js>)
		.build();
	
	<jc>// Create a proxy interface.</jc>
	IAddressBook ab = client.getRemoteableProxy(IAddressBook.<jk>class</jk>);
	
	<jc>// Invoke a method on the server side and get the returned result.</jc>
	Person p = ab.createPerson(
		<jk>new</jk> CreatePerson(<js>"Test Person"</js>,
			AddressBook.<jsm>toCalendar</jsm>(<js>"Aug 1, 1999"</js>),
			<jk>new</jk> CreateAddress(<js>"Test street"</js>, <js>"Test city"</js>, <js>"Test state"</js>, 12345, <jk>true</jk>))
	);
		</p>
		<p>
			The requirements for a method to be callable through a remoteable service are:
		</p>
		<ul class='spaced-list'>
			<li>
				The method must be public.
			<li>
				The parameter and return types must be <a href='../../../../overview-summary.html#juneau-marshall.PojoCategories'>serializable and parsable</a>.
		</ul>
		<p>
			One significant feature is that the remoteable services servlet is a full-blown REST interface.  
			Therefore, in cases where the interface classes are not available on the client side, the same method calls 
			can be made through pure REST calls.  
			This can also aid significantly in debugging since calls to the remoteable service can be called directly 
			from a browser with no code involved.
		</p>
		<p>
			See <a class='doclink' href='../remoteable/package-summary.html#TOC'>org.apache.juneau.rest.remoteable</a> 
			for more information.
		</p> 
	</div>

	<!-- ======================================================================================================== -->
	<a id="Other"></a>
	<h3 class='topic' onclick='toggle(this)'>1.9 - Other Useful Methods</h3>
	<div class='topic'>
		<p>
			The {@link org.apache.juneau.rest.client.RestClientBuilder#rootUrl(Object)} method can be used to specify a 
			root URL on all requests so that you don't have to use absolute paths on individual calls.
		</p>
		<p class='bcode'>
	<jc>// Create a rest client with a root URL</jc>
	RestClient rc = RestClient.<jsm>create</jsm>().rootUrl(<js>"http://localhost:9080/foobar"</js>).build();
	String r = rc.doGet(<js>"/baz"</js>).getResponseAsString();  <jc>// Gets "http://localhost:9080/foobar/baz"</jc>
		</p>
		<p>
			The {@link org.apache.juneau.rest.client.RestClientBuilder#set(String,Object)} method can be used to 
			set serializer and parser properties.
			For example, if you're parsing a response into POJOs and you want to ignore fields that aren't on the
			POJOs, you can use the {@link org.apache.juneau.BeanContext#BEAN_ignoreUnknownBeanProperties} property.
		</p>
		<p class='bcode'>
	<jc>// Create a rest client that ignores unknown fields in the response</jc>
	RestClient rc = RestClient.<jsm>create</jsm>()
		.set(<jsf>BEAN_ignoreUnknownBeanProperties</jsf>, <jk>true</jk>)
		<jc>// or .ignoreUnknownBeanProperties(true)</jc>
		.build();
	MyPojo myPojo = rc.doGet(<jsf>URL</jsf>).getResponse(MyPojo.<jk>class</jk>);
		</p>
		<p>
			The {@link org.apache.juneau.rest.client.RestCall#retryable(int,long,RetryOn)} method can be used to 
			automatically retry requests on failures.
			This can be particularly useful if you're attempting to connect to a REST resource that may be in the 
			process of still initializing.
		</p>
		<p class='bcode'>
	<jc>// Create a rest call that retries every 10 seconds for up to 30 minutes as long as a connection fails
	// or a 400+ is received.</jc>
	restClient.doGet(<jsf>URL</jsf>)
		.retryable(180, 10000, RetryOn.<jsf>DEFAULT</jsf>)
		.run();
	</p>
	</div>
</div>
</body>
</html>