<!DOCTYPE HTML>
<!--
    Licensed Materials - Property of IBM
    (c) Copyright IBM Corporation 2014. All Rights Reserved.
   
    Note to U.S. Government Users Restricted Rights:  
    Use, duplication or disclosure restricted by GSA ADP Schedule 
    Contract with IBM Corp. 
 -->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<style type="text/css">
		/* For viewing in Page Designer */
		@IMPORT url("../../../../../../javadoc.css");

		/* For viewing in REST interface */
		@IMPORT url("../htdocs/javadoc.css");
		body { 
			margin: 20px; 
		}	
	</style>
	<script>
		/* Replace all @code and @link tags. */	
		window.onload = function() {
			document.body.innerHTML = document.body.innerHTML.replace(/\{\@code ([^\}]+)\}/g, '<code>$1</code>');
			document.body.innerHTML = document.body.innerHTML.replace(/\{\@link (([^\}]+)\.)?([^\.\}]+)\}/g, '<code>$3</code>');
		}
	</script>
</head>
<body>
<p>Jazz REST client API</p>

<script>
	function toggle(x) {
		var div = x.nextSibling;
		while (div != null && div.nodeType != 1)
			div = div.nextSibling;
		if (div != null) {
			var d = div.style.display;
			if (d == 'block' || d == '') {
				div.style.display = 'none';
				x.className += " closed";
			} else {
				div.style.display = 'block';
				x.className = x.className.replace(/(?:^|\s)closed(?!\S)/g , '' );
			}
		}
	}
</script>

<a id='TOC'></a><h5 class='toc'>Table of Contents</h5>
<ol class='toc'>
	<li><p><a class='doclink' href='#RestClient'>Jazz REST client API</a></p>
</ol>

<!-- ======================================================================================================== -->
<a id="RestClient"></a>
<h2 class='topic' onclick='toggle(this)'>1 - Jazz REST client API</h2>
<div class='topic'>
	<p>
		Juno provides a default REST client implementation for working with Jazz servers. 
		The client automatically detects and handles BASIC and FORM authentication and basic certificate authentication.
	</p>
	<p>
		The following code shows the Jazz REST client being used for querying and creating server messages on 
			a Jazz server.  The <code>ServerMessage</code> and <code>CreateServerMessage</code> classes
			are nothing more than simple beans that get serialized over the connection and reconstituted on 
			the server.
	</p>
	<p class='bcode'>
	System.<jsf>out</jsf>.println(<js>"Adding sample messages"</js>);

	DateFormat df = <jk>new</jk> SimpleDateFormat(<js>"yyyy-MM-dd'T'HH:mm:ssZ"</js>);
	String url = <js>"https://localhost:9443/jazz"</js>;
	String sms = url + <js>"/serverMessages"</js>;
	CreateServerMessage m;
	ServerMessage m2;
	String s1;
	ServerMessage[] messages;
	
	<jc>// Serializer for debug messages.</jc>
	WriterSerializer serializer = JsonSerializer.<jsf>DEFAULT</jsf>;
	
	<jc>// Create clients to handle JSON and XML requests and responses.</jc>
	RestClient jsonClient = <jk>new</jk> JazzRestClient(url, <js>"ADMIN"</js>, <js>"ADMIN"</js>)
		.setSerializer(JsonSerializer.<jk>class</jk>)
		.setParser(<jk>new</jk> JsonParser().addFilters(DateFilter.<jsf>ISO8601DTZ</jsf>.<jk>class</jk>));
	
	RestClient xmlClient = <jk>new</jk> JazzRestClient(url, <js>"ADMIN"</js>, <js>"ADMIN"</js>, XmlSerializer.<jk>class</jk>, XmlParser.<jk>class</jk>);
	
	<jc>// Delete any existing messages.</jc>
	messages = jsonClient
		.doGet(sms)
		.getResponse(ServerMessage[].<jk>class</jk>);
	
	<jk>for</jk> (ServerMessage message : messages) {
		<jk>int</jk> rc = jsonClient
			.doDelete(message.getUri())
			.execute();
		System.<jsf>out</jsf>.println(rc);	<jc>// Prints 200.</jc>
	}
	
	<jc>// Create an active server message.</jc>
	m = <jk>new</jk> CreateServerMessage(
		<jsf>INFO</jsf>,
		<js>"Test message #1"</js>,
		<js>"subTypeFoo"</js>,
		df.parse(<js>"2012-01-01T12:34:56EST"</js>),
		df.parse(<js>"2013-01-01T12:34:56EST"</js>));
	
	<jc>// POST the message, get response as string.</jc>
	s1 = jsonClient
		.doPost(sms, m)
		.getResponseAsString(); 
	System.<jsf>out</jsf>.println(<js>"TEST1: response="</js> + s1);

	<jc>// POST another message, get response as ServerMessage</jc>
	m = <jk>new</jk> CreateServerMessage(
		<jsf>INFO</jsf>,
		<js>"Test message #2"</js>,
		<js>"subTypeFoo"</js>,
		df.parse(<js>"2012-01-01T12:34:56EST"</js>),
		df.parse(<js>"2013-01-01T12:34:56EST"</js>));

	m2 = jsonClient
		.doPost(sms, m)
		.getResponse(ServerMessage.<jk>class</jk>); 
	System.<jsf>out</jsf>.println(<js>"TEST2: response="</js> + serializer.serialize(m2));
	
	<jc>// Create a future server message.</jc>
	m = <jk>new</jk> CreateServerMessage(
		<jsf>INFO</jsf>,
		<js>"Test message #3"</js>,
		<js>"subTypeFoo"</js>,
		df.parse(<js>"2013-01-01T12:34:56EST"</js>),
		df.parse(<js>"2014-01-01T12:34:56EST"</js>));
	
	m2 = jsonClient
		.doPost(sms, m)
		.getResponse(ServerMessage.<jk>class</jk>); 
	System.<jsf>out</jsf>.println(<js>"TEST3: response="</js> + serializer.serialize(m2));
	System.<jsf>out</jsf>.println(<js>"TEST3: id="</js> + m2.getItemId().getUuidValue());

	<jc>// Create a future server message using XML on both request and response.</jc>
	m = <jk>new</jk> CreateServerMessage(
		<jsf>INFO</jsf>,
		<js>"Test message #4"</js>,
		<js>"subTypeFoo"</js>,                                  
		df.parse(<js>"2013-01-01T12:34:56EST"</js>),
		df.parse(<js>"2014-01-01T12:34:56EST"</js>));
	
	s1 = xmlClient
		.doPost(sms, m)
		.getResponseAsString();
	System.<jsf>out</jsf>.println(<js>"TEST4: response="</js> + s1);

	<jc>// Get all the messages</jc>
	messages = jsonClient
		.doGet(sms)
		.getResponse(ServerMessage[].<jk>class</jk>);
	System.<jsf>out</jsf>.println(<js>"TEST5: response="</js> + serializer.serialize(messages)); 

	<jc>// Get the first ID</jc>
	URI firstMessageUrl = messages[0].getUri();
	
	System.<jsf>out</jsf>.println(<js>"firstMessageUrl=["</js>+firstMessageUrl+<js>"]"</js>);
	
	<jc>// Get the Date of the first ID.</jc>
	Date startDate = jsonClient
		.doGet(firstMessageUrl + <js>"/startDate"</js>)
		.getResponse(Date.<jk>class</jk>);  
	System.<jsf>out</jsf>.println(<js>"TEST5: response.startDate="</js>+startDate);
	
	<jc>// Change the start and end dates on first message</jc>
	m = <jk>new</jk> CreateServerMessage(
		<jsf>INFO</jsf>,
		<js>"Test message #3 overwritten"</js>,
		<js>"subTypeFooBar"</js>,
		df.parse(<js>"2023-01-01T12:34:56EST"</js>),
		df.parse(<js>"2024-01-01T12:34:56EST"</js>));
	s1 = jsonClient.doPut(firstMessageUrl, m).getResponseAsString();
	System.<jsf>out</jsf>.println(<js>"TEST6: response="</js>+s1);
	</p>
</div>
</body>
</html>